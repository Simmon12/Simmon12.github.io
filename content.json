[{"title":"js的继承","date":"2018-03-09T13:12:16.000Z","path":"2018/03/09/js的继承/","text":"一. 曾经一段时间因为Javascript关于类实现继承的不规范，导致出现了许多实现继承的代码，但实际上，所有的继承方式都是基于以下两种方式:1 通过原型链, 即子类的原型指向父类的实例从而实现原型共享2 借用构造函数, 即通过js的apply(参数)，call(数组)实现子类调用父类的属性，方法原型链方式可以实现所有属性方法共享,但无法做到属性，方法共享(例如Sub1修改了父类的函数(引用类型的值)，其他所有的子类Sub2、Sub3…想调用旧的函数就无法实现了)而借用构造函数除了能独享属性、方法外还能在子类构造函数中传递参数，但代码无法复用。总体而言就是可以实现所有属性方法独享，但无法做到属性、方法共享（例如，Sub1新增了一个函数，然后想让Sub2、Sub3…都可以用的话就无法实现了，只能Sub2、Sub3…各自在构造函数中新增） 二. 组合继承就是把以上两种继承方式一起使用组合继承把共享的属性，方法用原型链继承实现，独享的属性，方法用借用构造函数实现，几乎完美实现了js的继承。但是存在一个缺点：组合继承在实现的时候需要调用两次超类，使得原本父类函数中的属性和方法存在两个地方，一个是在子类的实例上，一个是在子类的原型上，性能不合格 三. 基于组合继承的上述缺点，寄生继承就出现了 寄生继承的思路跟工厂模式差不多，就是调用一个仅用于封装继承过程的函数； 这个继承思路也是由克罗克福德推广的，没错！就是实现那个“原型式继承”的大神。（在很多类库源码中都能发现它的身影）简单而言，寄生继承就是不用实例化父类了，直接实例化一个临时副本实现了相同的原型链继承。（即子类的原型指向父类副本的实例从而实现原型共享）","comments":true,"categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://simmon12.github.io/tags/javascript/"}]},{"title":"vue学习之data","date":"2018-02-11T09:56:08.000Z","path":"2018/02/11/vue学习之data/","text":"data 必须是函数data必须是函数12345&lt;div id=\"example-2\"&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt;&lt;/div&gt; 123456789101112var data = &#123; counter: 0 &#125;Vue.component('simple-counter', &#123; template: '&lt;button v-on:click=\"counter += 1\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', // 技术上 data 的确是一个函数了，因此 Vue 不会警告， // 但是我们却给每个组件实例返回了同一个对象的引用 data: function () &#123; return data &#125;&#125;)new Vue(&#123; el: '#example-2'&#125;) 上面是vue官网给的解释例子，如果data不是一个函数，那么之前所创建的三个组件会共享同一个data对象，因此递增一个counter会影响所有组件，这就会发生错误。我们可以通过为每个组件返回全新的数据对象来修复这个问题12345data: function () &#123; return &#123; counter: 0 &#125;&#125;","comments":true,"categories":[],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://simmon12.github.io/tags/Vue-js/"}]},{"title":"Vue打包上线遇到的坑","date":"2018-02-05T05:47:29.000Z","path":"2018/02/05/Vue打包上线遇到的坑/","text":"vue-cli项目打包出现空白页和路径错误问题对于Vue项目进行打包的时候命令行输入: npm run build 执行完毕后，项目中会出现一个新的文件夹dist, 随后将该文件夹dist放到服务器tomcat的webapps目录下就可以了。 但是，当我直接打开dist文件下的index.html文件的时候，页面完全是空白的，主要是以下两个问题引起的。 1. 文件引用路径错误123456789// 解决方式：到config文件夹中打开index.js文件。// 文件里面有两个assetsPublicPath属性，更改第一个，也就是更改build里面的assetsPublicPath属性：build: &#123; env: require('./prod.env'), index: path.resolve(__dirname, '../dist/index.html'), assetsRoot: path.resolve(__dirname, '../dist'), assetsSubDirectory: 'static', assetsPublicPath: './', // 原本是 '/' 改为'./' productionSourceMap: true, 2. router-view中的内容显示不出来，原因是：路由使用了history模式,这个坑是当你使用了路由之后，在没有后端配合的情况下就手贱打开路由history模式的时候，打包出来的文件也会是一片空白1234567// 解决方式: 将mode: 'history' 注释掉，将这个模式关闭即可let router = new Router(&#123; // mode: 'history', // 如果不配置mode，就会使用默认的hash模式，该模式下会将路径格式化为#！开头 routes: [ &#123; path: '/', redirect: '/home' &#125;, 如果要打开这个模式，必须配置好后端，详情可以看路由配置","comments":true,"categories":[],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://simmon12.github.io/tags/Vue-js/"}]},{"title":"<<Node入门>>书总结","date":"2018-01-26T13:53:47.000Z","path":"2018/01/26/Node入门-书总结/","text":"读《Node.js入门》的笔记 虽然之前曾经用node写过后台，但是node.js究竟是怎样的，我只是会用而已，所以打算开始恶补nodejs，进行系统的学习，所以首先看了《Node.js入门》这本书，原文地址用node.js实现用户上传图片，然后我们将图片显示在浏览器中。完成需要以下四个文件 index.js server.js router.js requestHandles.js index.js1234567891011var server = require('./server');var router = require('./router');var requestHandles = require('./requestHandles');var handle = &#123;&#125;;handle[\"/\"] = requestHandles.start;handle[\"/start\"] = requestHandles.start;handle[\"/upload\"] = requestHandles.upload;handle[\"/show\"] = requestHandles.show;server.start(router.route, handle); server.js1234567891011121314var http = require(\"http\");var url = require(\"url\");function start(route, handle) &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; console.log(\"Requst for \" + pathname + \"received\"); route(handle, pathname, response, request); &#125; http.createServer(onRequest).listen(8888); console.log(\"Server has started\");&#125;exports.start = start; router.js12345678910111213function route(handle, pathname, response, request) &#123; console.log(\"About to route a request for \" + pathname); if(typeof handle[pathname] === 'function') &#123; handle[pathname](response, request); &#125;else &#123; console.log(\"No request handler found for \" + pathname); response.writeHead(404, &#123;\"Content-Type\": \"text/html\"&#125;); response.write(\"404 Not found\"); response.end(); &#125;&#125;exports.route = route; requestHandles.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263var querystring = require(\"querystring\");var fs = require(\"fs\");var formidable = require(\"formidable\");function start(response) &#123; console.log(\"Requst handler 'start' was called\"); var body = '&lt;html&gt;'+ '&lt;head&gt;'+ '&lt;meta http-equiv=\"Content-Type\" content=\"text/html; '+ 'charset=UTF-8\" /&gt;'+ '&lt;/head&gt;'+ '&lt;body&gt;'+ '&lt;form action=\"/upload\" enctype=\"multipart/form-data\" '+ 'method=\"post\"&gt;'+ '&lt;input type=\"file\" name=\"upload\" multiple=\"multiple\"&gt;'+ '&lt;input type=\"submit\" value=\"Upload file\" /&gt;'+ '&lt;/form&gt;'+ '&lt;/body&gt;'+ '&lt;/html&gt;'; response.writeHead(200, &#123;\"Content-Type\": \"text/html\"&#125;); response.write(body); response.end();&#125;function upload(response, request) &#123; console.log(\"about to parse\"); var form = new formidable.IncomingForm(); form.uploadDir = 'tmp'; console.log(\"about to parse\"); form.parse(request, function(error, fields, files) &#123; console.log(\"parsing done\"); fs.renameSync(files.upload.path, \"./tmp/test.png\"); //var readStream = fs.createReadStream(files.upload.path); //var writeStream = fs.createWriteStream(\"./tmp/test.png\"); //readStream.pipe(writeStream); //readStream.on('end', function() &#123; // fs.unlinkSync(files.upload.path); //&#125;) response.writeHead(200, &#123;\"Content-Type\":\"text/html\"&#125;); response.write(\"received image:&lt;br/&gt;\"); response.write(\"&lt;img src='/show'/&gt;\"); response.end(); &#125;);&#125;function show(response) &#123; console.log(\"Requst handler 'show' was called\"); fs.readFile(\"./tmp/test.png\", \"binary\", function(error, file) &#123; if(error) &#123; response.writeHead(500,&#123;\"Content-Type\":\"text/plain\"&#125;); response.write(error + \"\\n\"); response.end(); &#125;else &#123; response.writeHead(200, &#123;\"Content-Type\": \"image/png\"&#125;); response.write(file, \"binary\"); response.end(); &#125; &#125;);&#125;exports.start = start;exports.upload = upload;exports.show = show; 上传文件部分常见问题在处理函数upload中，直接调用fs.renameSync方法会发生以下错误原因是：跨磁盘分区移动或者操作文件会有权限问题。 有两种解决方法第一种：主要利用fs的createReadStream、createWriteSream和unlinkSync方法12345678910111213141516171819function upload(response, request) &#123; console.log(\"about to parse\"); var form = new formidable.IncomingForm(); console.log(\"about to parse\"); form.parse(request, function(error, fields, files) &#123; console.log(\"parsing done\"); // fs.renameSync(files.upload.path, \"./tmp/test.png\"); var readStream = fs.createReadStream(files.upload.path); var writeStream = fs.createWriteStream(\"./tmp/test.png\"); readStream.pipe(writeStream); readStream.on('end', function() &#123; fs.unlinkSync(files.upload.path); &#125;) response.writeHead(200, &#123;\"Content-Type\":\"text/html\"&#125;); response.write(\"received image:&lt;br/&gt;\"); response.write(\"&lt;img src='/show'/&gt;\"); response.end(); &#125;);&#125; 第二种 添加一个 form.uploadDir=’tmp’ 即可（写一个临时路径）1234567891011121314function upload(response, request) &#123; console.log(\"about to parse\"); var form = new formidable.IncomingForm(); form.uploadDir = 'tmp'; console.log(\"about to parse\"); form.parse(request, function(error, fields, files) &#123; console.log(\"parsing done\"); fs.renameSync(files.upload.path, \"./tmp/test.png\"); response.writeHead(200, &#123;\"Content-Type\":\"text/html\"&#125;); response.write(\"received image:&lt;br/&gt;\"); response.write(\"&lt;img src='/show'/&gt;\"); response.end(); &#125;);&#125;","comments":true,"categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://simmon12.github.io/tags/Node-js/"}]},{"title":"大三寒假","date":"2018-01-23T07:36:09.000Z","path":"2018/01/23/大三寒假/","text":"","comments":true,"categories":[],"tags":[]},{"title":"JavaScript this决策树","date":"2017-12-19T03:13:15.000Z","path":"2017/12/19/JavaScript-this决策树/","text":"Javascript this 到底指向什么？ 前几天看了一篇技术博客，里面通过使用Javascript决策树的方式讲述了this的指向问题，看完之后收益匪浅，觉得一定要好好地记录下来作笔记，原文地址 不同于现在一些主流的面向对象的语言(比如java和c++)this含义是明确且确定的，this指向的都是当前对象，并且在编译时期就绑定了。而JavaScript中的this是在运行期进行绑定的，因此，在不同的场景下，Js中的this所指向的对象是不同的。 当函数的调用方式不同的时候，JavaScript中this不同，可以是全局对象，当前对象或者是任意的对象。JavaScript中函数调用的几种方式：作为对象方法调用，作为函数调用，作为构造函数调用，使用apply或call调用。作者用了一张决策树图表解释了JavaScript this到底指向什么？ 例子：12345678var point = &#123; x: 0, y: 0, moveTo: function(x,y) &#123; this.x = this.x + x; this.y = this.y + y; &#125;&#125; point.moveTo()函数在“Javascript this 决策树”中的判定过程为： point.moveTo函数调用是用new进行调用么？不是，进入否分支， point.moveTo函数是用dot(.)进行调用的吗？是，进入是分支，所以这里的this指向dot之前的对象point, this.x实际上是point.x 1234function func(x)&#123; this.x=x;&#125;func(5); func(5)函数调用是用new进行调用吗？不是，进入否分支 func(5)函数调用是用dot(.)进行调用吗？否，进入否分支，所以这里的this指向全局变量window, 即this.x实际上是window.x 123456789101112131415161718192021var point = &#123; x: 0, y: 0, moveTo: function(x, y) &#123; //内部函数 var moveX = function(x) &#123; this.x = x; // this指向window &#125;; // 内部函数 var moveY = function(y) &#123; this.y = y; // this指向window &#125;; moveX(x); moveY(y); &#125;&#125;;point.moveTo(1,1);point.x; // =&gt;0point.y; // =&gt;0x; // =&gt;1;y; // =&gt;1 point.moveTo(1,1)函数内部调用的是moveX()和moveY()函数，这两个函数中的this指向判定过程 moveX(1)函数调用是用new进行调用的么？不是，进入否分支 moveX(1)函数使用用dot进行调用的吗，否，进入否分支，所以this指向全局window，所以this.x 实际上是window.x; 下面看一个作为构造函数调用的例子123456789function Point(x, y) &#123; this.x = x; // this ? this.y = y; // this ? &#125;var np = new Point(1, 1);np.x; // 1var p = Point(2,2);p.x; // error p是一个空对象undefinedwindow.x // 2 Point(1,1)函数在 var np = new Point(1,1)中this的决策过程 var np = new Point(1,1)调用时用new调用么？是，进入是分支，this指向np 所以这里this.x = np.x = 1; Point(2,2)在决策树的判决过程 var p = Point(2, 2)调用是用new 进行调用么？不是，进入否分支， 上述是用dot调用么？不是，进入否分支，所以this指向window，所以this.x = 2, 也就是window.x = 2 最后是一个函数用call和apply进行调用的例子123456789101112function Point(x, y) &#123; this.x = x; this.y = y; this.moveTo = function(x, y) &#123; this.x = x; this.x = y; &#125;&#125;var p1 = new Point(0, 0);var p2 = &#123;x:0, y: 0&#125;;p1.moveTo.apply(p2, [10,10]); // apply实际上为p2.moveTo(10,10)p2.x; // 10 p1.moveTo.apply(p2, [10,10])函数在”Javascript this 决策树”中进行判定的过程首选，apply和call这两个方法异常强大，允许切换函数执行的上下文环境(context)， 即this绑定的对象。p1.moveTo.apply(p2, [10,10])实际上是p2.moveTo(10,10)，那么p2.moveTo(10,10)可解释为： p2.moveTo(10,10)函数调用时用new进行调用吗？不是，进入“否”分支 函数是用dot调用吗是，进入是分支，这里的this指向dot前的对象p2, 所以 p2.x =10; 原作者说道理解下一段话对于理解Javascript函数有很大的作用 Javascript中的函数既可以被当做普通函数执行，也可以作为对象的方法执行，这是导致this含义如此丰富的主要原因。一个函数被执行的时候，会创建一个执行环境，函数的所有的行为均发生在此执行环境中，构建该执行环境时，JavaScript首先会创建arguments变量，其中包含调用函数时传入的参数。接下来创建作用域链。然后初始化变量，首先初始化函数的形参表，值为arguments变量中对应的值，如果arguments变量中没有对应值，则该形参初始化为undefined。如果该函数中含有内部函数，则初始化这些内部函数，如果没有，继续初始化该函数内定义的局部变量，需要注意的是此时这些变量初始化为undefined，其赋值操作在执行环境创建成功后，函数执行时才会执行，这点对于我们理解Javascript中的变量作用域非常重要，最后为this变量赋值，如前所述，会根据函数调用方式的不同，赋给this全局对象，当前对象等。至此，函数的执行环境创建成功，函数开始逐行执行，所需变量均从之前构建好的执行环境中读取。","comments":true,"categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://simmon12.github.io/tags/javascript/"}]},{"title":"大三上WEB Project项目总结","date":"2017-12-19T02:12:35.000Z","path":"2017/12/19/大三上WEBProject项目总结/","text":"基于Java web的电影影评网站 点此获得源码和实验报告 这次的项目是和队友一起合作完成，主要涉及到的技术栈如下 jsp页面 数据库使用的是MySQL 项目存在的优缺点 优点：前端的实现为原生，但是很多好的样式是copy网上代码的，比如涉及CSS sticky footer使得footer能永远在内容的最底部，怎么做到的呢，课后必须花时间学习。登陆框，注册框，遮罩层的样式也是基本用了网上的代码，必须后面自己学习，电影详情页的海报样式必须自学。后端拦截也实现了，md5密码加密 缺点：主页登录注册部分每次按按钮都是重新加载页面， 不好，没有做到异步刷新，同样电影详情的评论也没有做到局部刷新和异步更新，增加电影页面用户交互感不好，没有错误提示 思考 这一次的前端没有使用框架，感觉没有使用框架，原生的方式实现并没有想象中困难，然而当用上框架的时候，不论是vue，angular，Jquery，在一定程度上都会有些冗余，以前在使用框架的时候，没有想明白为什么要使用框架，只是在学习的过程中看到网上的人总结说框架能简化开发，把重心多放在逻辑上，但是我并没有太多的这种感觉，尤其是这一次，我突然很想问：为什么存在前端框架？ jsp的优缺点： jsp = html+java，jsp与Java Servlet一样在服务器端执行，通常返回客户端一个html文本(JSP页面由HTML代码和嵌入其中的Java代码所组成。服务器在页面被客户端请求以后对这些Java代码进行处理，然后将生成的HTML页面返回给客户端的浏览器) 缺点：JSP运行将java代码插入到html中，使得内容能混合到表示上，业务逻辑也会进入到jsp页面中 后期改进 用nodejs做后端，mongodb做数据库，实现前后端分离。","comments":true,"categories":[],"tags":[{"name":"项目总结","slug":"项目总结","permalink":"https://simmon12.github.io/tags/项目总结/"}]},{"title":"MVVM框架","date":"2017-10-21T03:50:53.000Z","path":"2017/10/21/MVVM框架/","text":"MVVM框架笔记 MVVM的英文全称为：Model-View-ViewModel 核心为：数据模型的数据双向绑定 主要包括一下三个部分 ViewModel作为观察者的角色： 当Model层数据发生变化，ViewModel能观察到数据发生的变化，然后通知对于的视图View作出变化 当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据Model作变动 通过上述两种方式，实现 数据的双向绑定 MVVM框架的优点 针对有复杂交互逻辑的前端应用，可以省去许多手动触发DOM操作 通过Ajax数据持久化，可以进行局部刷新 常见的MVVM框架有：Angular.js , react.js vue.js","comments":true,"categories":[],"tags":[]},{"title":"thought","date":"2017-09-23T04:56:00.000Z","path":"2017/09/23/thought/","text":"记大三上一个雨后的中午广州的天气和往常一般调皮，毫无征兆地下雨，毫无征兆地停雨。我已经在这个世界留下了20年的痕迹，想起自己身边的人，小学，初中，高中，我们曾经呆在同一间教室，曾经困扰于同一道解析几何题，然而步入大学之后，就好像到了一个分岔路口，每个人似乎都朝着自己的方向渐行渐远。","comments":true,"categories":[],"tags":[{"name":"感想","slug":"感想","permalink":"https://simmon12.github.io/tags/感想/"}]},{"title":"响应式设计(一)","date":"2017-09-07T15:33:34.000Z","path":"2017/09/07/响应式设计/","text":"响应式网站的概念 流动网格，弹性图片和媒介查询是响应式设计的三大技术成分，但是崭新的思路也是必不可少的。与其把同样的内容割裂成不同设备专属的体验，我们可以通过媒介查询，渐进增强式地将一个设计在不同的阅读环境中加以优化。这么说并不是要绝对否定在任何情况下使用针对特定设备的独立网站，比如当移动用户在你的网站上的商业目的相比固定电脑用户要单一得多的时候，为两种情况分别输送不同的内容可能是最好的方法。然而我们也不需要固守在那样的设计思路里。如今越来越需要我们的设计能够呈现在一系列多种多样的体验中。响应式设计为我们指出了一条未来的路，是我们终于可以依照万物生灭的规律来进行设计了。来自: Responsive Web Design作者：伊森·马考特（Ethan Marcotte）https://site.douban.com/186898/widget/notes/10926516/note/241877629/ 响应式网站的组成 flexible grid layout 弹性网格布局 flexible image 弹性图片 media queries 媒介查询 常用的简单的可缩放的布局方式1234567.container &#123; width: 100%;&#125;.content &#123; width: 90%; margin: 2px auto;&#125; 在设置内容width属性的时候，不要直接设定特定的像素大小，而是通过百分比的方式，这样，当页面进行缩放的时候，宽度不会死死的固定，样式更加整体化和灵活。 媒介查询在CSS2中12&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"site.css\" media=\"screen\"/&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"print.css\" media=\"print\"/&gt; 在CSS3中1234@media all and (min-width: 800px) and (orientation: landscape) &#123; ......&#125;// all 可以是各种媒体设备，也可以是screen等，当只是针对某种设备的时候，为了兼容老的浏览器，最好在媒体设备前加上only，当and后面的表达式为真的时候，括号里的样式才会显示出来 viewport 视口 width：视口宽度 device-width: 设备屏幕的宽度 在桌面浏览器的时候，视口指的是浏览器主窗口的区域。在手机浏览器中，会出现3个视口概念 布局视口: 默认大小是厂商的值，一般为960px 可视视口（缩放时，可视视口是会发生改变的，默认是手机屏幕的大小） 理想视口：理想视口是布局视口在一个设备上的最佳尺寸，理想视口下的页面便于浏览器浏览阅读，不需要进行缩放。实现理想视口：（在响应式网站中最起码要有以下的语句）1&lt;meta name=\"viewport\" content=\"width=device-width\"/&gt; 用户在手机上不用进行缩放，体验会非常好，有一些甚至会禁止缩放如百度1234&lt;meta name=\"viewport\" content=\"width=device-width,minimum-scale = 1.0, //最小的缩放比例 maximum-scale = 1.0, // 最大的缩放比例user-scalable = no\"/&gt; // 禁用了用户缩放 em, rem, px一. px二. em 一种相对的长度单位，更加适合响应式设计 em相对的参照物为父元素的font-size 当一直向上找到html都没有设置font-size的时候，浏览器会有一个默认的em设置： 1em = 16px三. rem的相对参照物为根元素html，相于参照固定不变，所以好算，同样当没有设置font-size时，浏览器会有一个默认的rem设置：1rem = 16px一些单位的转换 font-size: 62.5% 1rem = 10px (10/16*100%) font-size: 100% 1rem = 16px 响应式图片一. 滚动式组件推荐（OwlCarousel2）二. 挑选第三方组件的标准 使用人数 是否开源 文档是否齐全 活跃性 小巧够用的组件（轻量级）三. 实现响应式图片的方式 js或服务端1234567891011121314$(document).ready(function() &#123; function makeImageResponsive() &#123; var width = $(window).width(); var img = $('.content img'); if (width &lt;= 480) &#123; img.attr('src', 'img/480.png'); &#125; else if (width &lt;= 800) &#123; img.attr('src': 'img/800.png'); &#125; else &#123; img.attr('src': 'img/1600.png'); &#125; &#125; $(window).on('resize load': makeImageResponsive);&#125;) 属于命令性的实现 srcset配合sizes 123&lt;img class=\"image\" src=\"img/480.png\" srcset = \"img/480.png 480w, img/800.png 800w, img/1600.png 1600w\" sizes=\"x\"&gt; x的值是包含这张图片的div的大小(50% 50vw, 50px 50px) picture（使用picturefill.min.js填补一些浏览器不支持picture标签的坑） 12345&lt;picture&gt; &lt;source srcset=\"img/ad001-l.png\" media=\"(min-width: 50em)\"&gt; &lt;source srcset=\"img/ad001-m.png\" media=\"(min-width: 30em)\"&gt; &lt;img src=\"img/ad001.png\" alt=\"2015年度报告\"&gt;&lt;/picture&gt; svg 压缩图片的网站地址https://tinyping.com做网站时，尤其是从设计师哪来的图片，通过压缩，可以提升页面载入速度，有时候可能会比优化代码时提升的速度还要快。","comments":true,"categories":[],"tags":[{"name":"响应式","slug":"响应式","permalink":"https://simmon12.github.io/tags/响应式/"}]},{"title":"随笔","date":"2017-04-17T02:08:39.000Z","path":"2017/04/17/随笔/","text":"忙碌的大二，迷茫的内心 忙里偷闲的一次博客，其实我是没有时间来写这篇博客的，我觉得写完这篇博客，也许就到了吃饭时间，这样本可以用来做OS实验的时间就没了，但是我还是选择了写博客，不为别的，只为写写自己所想所思的，清明的时候没有回家，呆在学校呆了3天，每天学学习，看看剧，偶尔睡睡午觉，偷偷懒，这种生活很惬意。去外面剪了个头发，与之前不同的是剪了个刘海，想说换换心情，换换形象。但是好像中分已经稳固地不能撼动了，刘海老是中分，导致出现此刻用笔盖夹刘海的我，可能之前有刘海的时光再也回不去了，就好像小时候那种学校出游前一晚那种激动兴奋的心情再也体会不到一样，有时候想想真的很难过。我的大二异常地忙碌，每天不是在做实验，就是在写报告的路上，我好像收获了很多，又好像并没有得到些什么，自己想学的东西，没学，看到别人的努力和认真，自己很羡慕很嫉妒，然而自己却没作出半点尝试，身边的人很优秀，自己很渣，但是换另外一个角度想想，我在一些人的眼里是不是或许也是优秀的人。但是我换不了角度，很多人说，要自信，要乐观，不要老是在意别人的目光，不要老是看别人，但是这些都只是说，谁能做到，说的好听，做的难。所以我有时候不懂得怎么去安慰别人，我连自己都安慰不了，怎么安慰别人，我说不出那些大道理，因为我做不到。这个星期又有一大堆实验，各种ddl又来了，又是各种熬夜，上星期天气冷，下了个水，就发烧了，感觉自己弱爆了。果然熬夜不行啊！！！我不想每次都找借口，前端还有一大堆的东西没学呢！！！","comments":true,"categories":[],"tags":[{"name":"感想","slug":"感想","permalink":"https://simmon12.github.io/tags/感想/"}]},{"title":"Git","date":"2017-04-06T16:59:13.000Z","path":"2017/04/07/Git/","text":"Windows下Git的安装和使用详细教程： http://blog.jobbole.com/78960/ Linux下Git的安装和使用详细教程: http://www.cnblogs.com/20145335hh/p/5954564.html","comments":true,"categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://simmon12.github.io/tags/Git/"}]},{"title":"javascript 练习分析(四)","date":"2017-04-02T11:04:10.000Z","path":"2017/04/02/原型/","text":"对原型练习的理解12345function Ninja() &#123;&#125;var ninja = new Ninja();assert(typeof ninja == \"object\", \"However the type of the instance is still an object\");assert(ninja instanceof Ninja, \"The object was instantiated properly.\");assert(ninja.constructor == Ninja, \"The ninja object was created by the Ninja function\"); 知识点分析 1.创建对象之构造函数模式 123456789function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; alert(this.name); &#125;;&#125;var person1 = new Person(\"ss\", 20, \"software Engineer\"); 注意: 函数名Person使用的是大写字母P，按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头，并且构造函数本身也是函数，只不过用于创建对象而已。 创建Person的新实例，必须使用new操作符，若var person1 = Person(), 则person1是undefined。person1对象有一个constructor(构造函数)属性，该属性指向Person。准确来说constructor属性关联的就是当初创建这个对象实例的构造函数。 所以在开篇代码中ninja.constructor == Ninja。 typeof ninja == “object” 其中 typeof是一个操作符，用来测定给定变量的数据类型。 “undefined” — 如果这个值未定义 “boolen” ——–如果这个值是布尔值 “string”———-如果这个值是字符串 “number”——–如果这个值是数字 “object”———-如果这个值是对象或null ”function“——-如果这个值是函数 ninja instanceof Ninja ,其中instanceof运算符用来测试一个对象在其原型链中是否存在一个构造函数的prototype属性. 语法: object instanceof constructor object : 要检测的对象 constructor: 某个构造函数","comments":true,"categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://simmon12.github.io/tags/javascript/"}]},{"title":"javascript练习分析-三","date":"2017-03-21T02:59:20.000Z","path":"2017/03/21/javascript练习分析-三/","text":"Closures(闭包)123456789101112function f1() &#123; var n = 999; nAdd = function() &#123;n+=1&#125; function f2() &#123; alert(n)&#125;; return f2;&#125;var result = f1();result(); // 999;nAdd();result(); //1000;nAdd();result(); //1001; 读书笔记一.闭包是指有权访问另一个函数作用域中的变量的函数，闭包最大的两个用处是：a.可以读取函数内部的变量 b. 让这些变量的值始终保持在内存中.在上面的代码中，result实际上就是闭包函数f2,它一共运行了3次，第一次为999，第二次，第三次一次为1000，1001，这说明了函数f1的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。因为f1是f2的父函数，而f2被赋值给一个全局变量reslut，这导致f2始终在内存中，而f2依赖f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制回收。在第一点的解释中设计到一些知识点，需要了解这些知识点才能更好地了解闭包1.作用域链当代码在一个环境中执行时，会创建变量对象的一个作用域链，其用途是保证对执行环境有权访问的所有变量和函数的有序访问。 作用域的前端，始终都是当前执行的代码所在环境的变量对象，若这个环境是函数，则将其活动对象作为变量对象。作用域链中的下一个变量对象来自包含环境，而再下一个变量对象则来自下一个包含环境，这样一直延续到全局执行环境。标识符解析是沿着作用域链一级一级地搜索标识符地过程，都是从作用域链的前端开始，然后逐级往后，直到找到标识符。注意的是：如果在逐级往后搜索的过程中找到标识符，则马上停止搜索，即如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符。2.变量的作用域(全局变量和局部变量)与C++等语言的重要区别之一是，javascript是没有块级作用域的，即并不是以花括号{}封闭的来拥有自己的作用域，而是以函数function为分界。区分全局变量和局部变量，只需理解这一点: 使用var声明的变量自动被添加到最接近的环境中，而如果初始变量时没有使用var声明，该变量会自动被添加到全局变量 3.垃圾收集机制(后续补充)闭包与变量闭包只能取得包含函数(即外部函数)中任何变量的最后一个值，闭包所保存的是整个变量对象，而不是某个特殊的变量12345678910111213141516171819202122function creatFunction() &#123; var result = new Array(); for (var i = 0; i &lt; 10; i++) &#123; result[i] = function () &#123; return i; &#125;; &#125; return result; //result=[10,10,10,...,10]返回一个都是10的数组，因为每个函数的作用域链中都&#125; //保存着crcreatFunction()函数的活动对象，所以他们引用的都是同一个变量i，crcreatFunction函数返回后，i的值是10； //创建另一个匿名函数强制让闭包的行为符合预期function creatFunction() &#123; var result = new Array(); for(var i = 0; i &lt; 10; i++) &#123; result[i] = function(num) &#123; return function() &#123; return num; &#125; &#125;(i); &#125; return result; //result = [0,1,2,3,4,...9]&#125;","comments":true,"categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://simmon12.github.io/tags/javascript/"}]},{"title":"常见函数模板总结","date":"2017-03-18T03:08:55.000Z","path":"2017/03/18/常见函数模板总结/","text":"判断是否为素数12345678910function isPrime( num ) &#123; var prime = num != 1; //Everything but 1 can be prime for(var i = 2; i &lt; num ; i++) &#123; if(num &amp; i == 0) &#123; prime = false; break; &#125; &#125; return prime;&#125;","comments":true,"categories":[],"tags":[{"name":"template","slug":"template","permalink":"https://simmon12.github.io/tags/template/"}]},{"title":"Javascript练习分析(二)","date":"2017-03-17T06:26:26.000Z","path":"2017/03/17/Javascript练习分析-二/","text":"Function 笔记12345678910111213var ninja = &#123; yell: function(n) &#123; return n &gt; 0 ? ninja.yell(n-1) + \"a\" : \"hiy\"; &#125;&#125;;console.log(ninja.yell(4)) // hiyaaaavar samurai = &#123; yell: ninja.yell &#125;;var ninja = null;try &#123; samurai.yell(4);&#125; catch(e) &#123; console.log(\"mistake\") &#125; //mistake 知识点梳理 一.函数是对象，函数名是指针(是指向函数对象的指针,不会与某个函数绑定)。 换句话说一个函数可能有多个名字。函数的名字仅仅只是一个包含指针的变量而已，因此，计时在不同的环境下执行，全局的某()函数和o.某()函数指向的仍然是同一个函数。二.函数声明提升(function declaration hoisting) 函数声明和函数表达式是存在区别的。解析器会率先读取函数声明，并使其在执行任何代码前可以访问；而函数表达式则必须等到解析器执行到它所在的代码行，才会真正被解释执行 12345678alert(sum1(10,10)); //20function sum1(n1, n2) &#123; return n1 + n2;&#125;alert(sum2(10,10)); // sum2 is not a function 运行错误var sum2 = function(n1, n2) &#123; return n1 + n2;&#125; 三.函数内部有两个特殊的对象，arguments和this。 arguments是一个类数组对象，包含着传入函数中的所有参数。arguments对象有一个叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。在最开始的递归调用代码中，sumurai.yell(4)会调用ninja()函数，但是ninja函数已经变为null，此时调用自然会发生错误。为了消除这种函数名与函数的执行耦合在一起的现象，可以使用arguments.callee。将代码改成如下所示，即可： 12345var ninja = &#123; yell: function(n) &#123; return n &gt; 0 ? arguments.callee(n-1) + 'a' : 'hiy'; //arguments.callee is the function itself. &#125;&#125;; caller这个属性中保存着调用当前函数的函数的引用，即与callee一样也是一个指针，不过caller指向的是调用当前函数的函数。 解决上面问题的第二种方法是给匿名函数命名 12345var ninja = &#123; yell: function yell(n) &#123; return n &gt; 0 ? yell(n-1) + \"a\" : \"hiy\"; &#125;&#125;; 四.重排序方法–reverse()和sort()默认情况下，sort()方法按升序排列数组项(从小到大),为了实现排序，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序，即使数组中的每一项都是数值，sort()方法比较的也是字符串。123var values = [0, 1, 5, 10, 15];values.sort();alert(values); // 0,1,10,15 出现10在5的前面的原因是：虽然数值5小于10，但是在进行字符串比较的时候，”10”位于”5”的前面。可见这种排序方式在很多情况下都不是最佳方案，所以sort()方法可以接收一个比较函数作为参数，以便指定哪个值位于哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则放回0，如果第一个参数应该位于第二个参数之后则返回一个正数。12345678function compare(value1, value2) &#123; if(value1 &lt; value2) return -1; else if(value1 == value2) return 0; else return 1;&#125;var values = [0,1,5,10,15];values.sort(compare);alert(values); //0,1,5,19,15 作为值的函数,函数名本身就是变量，因此可以从一个函数返回另外一个函数123456789101112131415// 可以根据某个对象属性对数组进行排序function createComparsionFunction(propertyName) &#123; return function(object1, object2) &#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; if(value1 &lt; value2) return -1; else if( value1 &gt; value2) return 1; else return 0; &#125;&#125;var data = [&#123;name: \"Zhang\", age: 28&#125;, &#123;name: \"feng\", age: 23&#125;];data.sort(createComparsionFunction(\"name\"));alert(data[0].name); //Zhangdata.sort(createComparsionFunction(\"age\"));alert(data[0].age); //23","comments":true,"categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://simmon12.github.io/tags/javascript/"}]},{"title":"javascript练习分析(一)","date":"2017-03-16T15:42:07.000Z","path":"2017/03/16/javascript练习分析/","text":"理解 Prototype.js的bind()函数fun.bind(this,arg1,arg2)bind()方法会创建一个新的函数，称为绑定函数，fun方法在this环境下调用(这里的this可以绑定到任意对象),该方法可传入连个参数，第一个参数作为this，第二个及以后的参数则作为函数的参数调用123456789// The .bind method from Prototype.jsFunction.prototype.bind = function() &#123; var fn = this, args = Array.prototype.slice.call(arguments), object = args.shift(); return function() &#123; return fn.apply(object, args.concat(Array.prototype.slice.call(arguments)); ) &#125;&#125; 一.Array.slice()和shift()和concat()slice()有两种，一种是string.slice()，另外一种是Array.slice().在数组Array中，slice()能够基于当前数组中的一或多个项创建一个新数组。它可以接受一个或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项，但不包括结束位置的项，注意，slice()方法不会影响原始数组shift()指删除一个数组最前面的值，并且放回删除值.concat()可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前一个数组的副本，然后接收到的参数添加到这个副本的末尾，最后返回新构建的数组。 var colors = [\"red\", \"green\", \"blue\", \"yellow\", \"purple\"]; var color1 = colors.concat(\"yellow\",[\"black\",\"brown\"]); var colors2 = colors.slice(1); var colors3 = colors.slice(1,4); alert(color1); //red,green,blue,yellow,purple,yellow,black,brown alert(colors2); //green,blue,yellow,purple alert(colors3); //green,blue,yellow alert(colors); //red,green,blue,yellow,purple 二.call()和apply()call()和apply()方法主要是用来扩充函数的作用域(把第一个参数作为自己的this)call()和apply()方法接收两个参数:apply():第一个参数是作用域，第二个是参数数组，其中第二个参数可以是数组实例，也可以是arguments对象。call():参数方式与apply一致，区别在于:传参的方式不同，其参数必须逐个写入 三.Array.prototype.slice.call(arguments)arguments是一个关键字，代表当前参数，在Javascript中虽然arguments表面上以数组形式来表示，但实际上没有原生slice的功能，所以要使用call方法算是对arguments对象不完整数组功能的修正。Array.prototype.slice.call(arguments) === Array.prototype.slice.call(arguments,0)Array.prototype.slice调用的是Array的原型方法，对于真正的数组是有slice()方法，但是对于像arguments或者自己定义的一些类数组对象虽然存在length等若干属性，但是并没有slice()方法，所以对于这种类数组对象就得使用原型方法来使用slice()方法，即Array.prototype.slice.(如果在自定义中的类数组对象中自定义了slice()方法，就可以自然地直接调用了)。因此，Array.prototype.slice.call(arguments,0)可以理解为：对于arguments类数组，我们调用Array.prototype.slice原型方法，并用call()方法将作用域限定在arguments中，此时：Array.prototype === arguments, 用参数0位slice()方法中地第一个参数，即开始位置索引，_通过这种方法就将arguments类数组转换位了真数组。 var a = { length: 2, 0: 'first', 1: 'second' }; Array.prototype.slice.call(a); //[\"first\",\"second\"] var a = {length: 2}; Array.prototype.slice.call(a); //[\"undefined\",\"undefined\"]","comments":true,"categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://simmon12.github.io/tags/javascript/"}]},{"title":"图解HTTP","date":"2017-03-05T07:00:59.000Z","path":"2017/03/05/图解HTTP/","text":"《图解HTTP》 读书笔记之网络基础TCP/IP计算机与网络设备要相互通信，双方就必须基于相同的方法，这些方法需要同一种规则，这种规则即称为协议。 像这样把与互联网相关联的协议集合起来总称为TCP/IP。","comments":true,"categories":[],"tags":[{"name":"HTTP协议","slug":"HTTP协议","permalink":"https://simmon12.github.io/tags/HTTP协议/"}]},{"title":"我的第一篇博客","date":"2017-02-07T08:32:48.000Z","path":"2017/02/07/我的第一篇博客/","text":"首先我必须说一点，从小到大我都觉得我的语言组织能力很差，怎么说呢？通常情况下，我会把一件事情说的特别的冗长，后来我仔细地想了想，其实这并不能完全怪我，要怪就得怪那万恶的高考语文作文，说了那么久的废话，我来谈谈正话，其实也不能算是正话，这篇文章的主要目的其实就是随便谈谈而已。 我很开心，为什么呢？因为我终于拥有了一篇属于自己的博客啦，我从大一的时候就一直希望自 己能弄出一个个人网站，因为我想成为一名前端工程师，我想如果我能够熟悉一个网站建立的全过程，我应该就能完整地了解前端后端的全过程，但是我发现这个过程异常的艰辛，偏偏我又是那种很难集中注意力坚持做完一件事的人，我不知道我能不能算是一个有恒心，肯坚持的人，因为一方面我很难坚持完成一件事超过一个小时，另一方面我，我却能长时间地想要完成那件事，我想除了学习，前端应该是我坚持最久的事情。 其实最初接触前端的原因，是因为我觉得它简单，并且前景好，作为一名在计算机专业中的稀有物种，我觉得我必须找到一个适合女生的工作，听到很多师兄师姐，以及网上的评论，说前端比较适合女生，于是乎，就这么开始了，然而越接触，越发现前端其实是巨坑，要学的东西多且杂,而且经常变化，但是我想着我现在才大二，只要我坚持下去，总会是好的。 大一下的时候萌生了弄一个个人博客的想法，想想不错，在博客上面分享自己的想法和记录平时的技术文章和感悟也是相当不错的。暑假一直在查，上网百度，但始终没有方向，因为看不懂，幸运的是，这个学期加了一个新社团，我们的主席，一个超级厉害的人物，给了我们很多干货 ，我觉得能学到的东西非常多，也特别庆幸自己能进到这个社团。然后就在主席的干货中，看到了hexo，发现原来建博客并不是一件难事，尽管如此，我还是捣腾了很多天，当然很大部分原因是因为，我老是没坚持超过2个小时，就去看电视或者玩手机，惭愧啊。 好了，我的博客生活已经开始了，我的博客，还很丑，期待自己后期的完善~~","comments":true,"categories":[],"tags":[{"name":"感想","slug":"感想","permalink":"https://simmon12.github.io/tags/感想/"}]},{"title":"Hello World","date":"2017-02-05T16:28:27.886Z","path":"2017/02/06/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","comments":true,"categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://simmon12.github.io/tags/Hexo/"}]}]