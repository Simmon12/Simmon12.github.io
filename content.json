[{"title":"Javascript练习分析(二)","date":"2017-03-17T06:26:26.000Z","path":"2017/03/17/Javascript练习分析-二/","text":"Function 笔记12345678910111213var ninja = &#123; yell: function(n) &#123; return n &gt; 0 ? ninja.yell(n-1) + \"a\" : \"hiy\"; &#125;&#125;;console.log(ninja.yell(4)) // hiyaaaavar samurai = &#123; yell: ninja.yell &#125;;var ninja = null;try &#123; samurai.yell(4);&#125; catch(e) &#123; console.log(\"mistake\") &#125; //mistake 知识点梳理 一.函数是对象，函数名是指针(是指向函数对象的指针,不会与某个函数绑定)。 换句话说一个函数可能有多个名字。函数的名字仅仅只是一个包含指针的变量而已，因此，计时在不同的环境下执行，全局的某()函数和o.某()函数指向的仍然是同一个函数。二.函数声明提升(function declaration hoisting) 函数声明和函数表达式是存在区别的。解析器会率先读取函数声明，并使其在执行任何代码前可以访问；而函数表达式则必须等到解析器执行到它所在的代码行，才会真正被解释执行 12345678alert(sum1(10,10)); //20function sum1(n1, n2) &#123; return n1 + n2;&#125;alert(sum2(10,10)); // sum2 is not a function 运行错误var sum2 = function(n1, n2) &#123; return n1 + n2;&#125; 三.函数内部有两个特殊的对象，arguments和this。 arguments是一个类数组对象，包含着传入函数中的所有参数。arguments对象有一个叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。在最开始的递归调用代码中，sumurai.yell(4)会调用ninja()函数，但是ninja函数已经变为null，此时调用自然会发生错误。为了消除这种函数名与函数的执行耦合在一起的现象，可以使用arguments.callee。将代码改成如下所示，即可： 12345var ninja = &#123; yell: function(n) &#123; return n &gt; 0 ? arguments.callee(n-1) + 'a' : 'hiy'; //arguments.callee is the function itself. &#125;&#125;; caller这个属性中保存着调用当前函数的函数的引用，即与callee一样也是一个指针，不过caller指向的是调用当前函数的函数。 解决上面问题的第二种方法是给匿名函数命名 12345var ninja = &#123; yell: function yell(n) &#123; return n &gt; 0 ? yell(n-1) + \"a\" : \"hiy\"; &#125;&#125;; 四.重排序方法–reverse()和sort()默认情况下，sort()方法按升序排列数组项(从小到大),为了实现排序，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序，即使数组中的每一项都是数值，sort()方法比较的也是字符串。123var values = [0, 1, 5, 10, 15];values.sort();alert(values); // 0,1,10,15 出现10在5的前面的原因是：虽然数值5小于10，但是在进行字符串比较的时候，”10”位于”5”的前面。可见这种排序方式在很多情况下都不是最佳方案，所以sort()方法可以接收一个比较函数作为参数，以便指定哪个值位于哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则放回0，如果第一个参数应该位于第二个参数之后则返回一个正数。12345678function compare(value1, value2) &#123; if(value1 &lt; value2) return -1; else if(value1 == value2) return 0; else return 1;&#125;var values = [0,1,5,10,15];values.sort(compare);alert(values); //0,1,5,19,15 作为值的函数,函数名本身就是变量，因此可以从一个函数返回另外一个函数123456789101112131415// 可以根据某个对象属性对数组进行排序function createComparsionFunction(propertyName) &#123; return function(object1, object2) &#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; if(value1 &lt; value2) return -1; else if( value1 &gt; value2) return 1; else return 0; &#125;&#125;var data = [&#123;name: \"Zhang\", age: 28&#125;, &#123;name: \"feng\", age: 23&#125;];data.sort(createComparsionFunction(\"name\"));alert(data[0].name); //Zhangdata.sort(createComparsionFunction(\"age\"));alert(data[0].age); //23","comments":true,"categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://simmon12.github.io/tags/javascript/"}]},{"title":"javascript练习分析(一)","date":"2017-03-16T15:42:07.000Z","path":"2017/03/16/javascript练习分析/","text":"理解 Prototype.js的bind()函数fun.bind(this,arg1,arg2)bind()方法会创建一个新的函数，称为绑定函数，fun方法在this环境下调用(这里的this可以绑定到任意对象),该方法可传入连个参数，第一个参数作为this，第二个及以后的参数则作为函数的参数调用123456789// The .bind method from Prototype.jsFunction.prototype.bind = function() &#123; var fn = this, args = Array.prototype.slice.call(arguments), object = args.shift(); return function() &#123; return fn.apply(object, args.concat(Array.prototype.slice.call(arguments)); ) &#125;&#125; 一.Array.slice()和shift()和concat()slice()有两种，一种是string.slice()，另外一种是Array.slice().在数组Array中，slice()能够基于当前数组中的一或多个项创建一个新数组。它可以接受一个或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项，但不包括结束位置的项，注意，slice()方法不会影响原始数组shift()指删除一个数组最前面的值，并且放回删除值.concat()可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前一个数组的副本，然后接收到的参数添加到这个副本的末尾，最后返回新构建的数组。 var colors = [\"red\", \"green\", \"blue\", \"yellow\", \"purple\"]; var color1 = colors.concat(\"yellow\",[\"black\",\"brown\"]); var colors2 = colors.slice(1); var colors3 = colors.slice(1,4); alert(color1); //red,green,blue,yellow,purple,yellow,black,brown alert(colors2); //green,blue,yellow,purple alert(colors3); //green,blue,yellow alert(colors); //red,green,blue,yellow,purple 二.call()和apply()call()和apply()方法主要是用来扩充函数的作用域(把第一个参数作为自己的this)call()和apply()方法接收两个参数:apply():第一个参数是作用域，第二个是参数数组，其中第二个参数可以是数组实例，也可以是arguments对象。call():参数方式与apply一致，区别在于:传参的方式不同，其参数必须逐个写入 三.Array.prototype.slice.call(arguments)arguments是一个关键字，代表当前参数，在Javascript中虽然arguments表面上以数组形式来表示，但实际上没有原生slice的功能，所以要使用call方法算是对arguments对象不完整数组功能的修正。Array.prototype.slice.call(arguments) === Array.prototype.slice.call(arguments,0)Array.prototype.slice调用的是Array的原型方法，对于真正的数组是有slice()方法，但是对于像arguments或者自己定义的一些类数组对象虽然存在length等若干属性，但是并没有slice()方法，所以对于这种类数组对象就得使用原型方法来使用slice()方法，即Array.prototype.slice.(如果在自定义中的类数组对象中自定义了slice()方法，就可以自然地直接调用了)。因此，Array.prototype.slice.call(arguments,0)可以理解为：对于arguments类数组，我们调用Array.prototype.slice原型方法，并用call()方法将作用域限定在arguments中，此时：Array.prototype === arguments, 用参数0位slice()方法中地第一个参数，即开始位置索引，_通过这种方法就将arguments类数组转换位了真数组。 var a = { length: 2, 0: 'first', 1: 'second' }; Array.prototype.slice.call(a); //[\"first\",\"second\"] var a = {length: 2}; Array.prototype.slice.call(a); //[\"undefined\",\"undefined\"]","comments":true,"categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://simmon12.github.io/tags/javascript/"}]},{"title":"图解HTTP","date":"2017-03-05T07:00:59.000Z","path":"2017/03/05/图解HTTP/","text":"《图解HTTP》 读书笔记之网络基础TCP/IP计算机与网络设备要相互通信，双方就必须基于相同的方法，这些方法需要同一种规则，这种规则即称为协议。 像这样把与互联网相关联的协议集合起来总称为TCP/IP。","comments":true,"categories":[],"tags":[{"name":"HTTP协议","slug":"HTTP协议","permalink":"https://simmon12.github.io/tags/HTTP协议/"}]},{"title":"我的第一篇博客","date":"2017-02-07T08:32:48.000Z","path":"2017/02/07/我的第一篇博客/","text":"首先我必须说一点，从小到大我都觉得我的语言组织能力很差，怎么说呢？通常情况下，我会把一件事情说的特别的冗长，后来我仔细地想了想，其实这并不能完全怪我，要怪就得怪那万恶的高考语文作文，说了那么久的废话，我来谈谈正话，其实也不能算是正话，这篇文章的主要目的其实就是随便谈谈而已。 我很开心，为什么呢？因为我终于拥有了一篇属于自己的博客啦，我从大一的时候就一直希望自 己能弄出一个个人网站，因为我想成为一名前端工程师，我想如果我能够熟悉一个网站建立的全过程，我应该就能完整地了解前端后端的全过程，但是我发现这个过程异常的艰辛，偏偏我又是那种很难集中注意力坚持做完一件事的人，我不知道我能不能算是一个有恒心，肯坚持的人，因为一方面我很难坚持完成一件事超过一个小时，另一方面我，我却能长时间地想要完成那件事，我想除了学习，前端应该是我坚持最久的事情。 其实最初接触前端的原因，是因为我觉得它简单，并且前景好，作为一名在计算机专业中的稀有物种，我觉得我必须找到一个适合女生的工作，听到很多师兄师姐，以及网上的评论，说前端比较适合女生，于是乎，就这么开始了，然而越接触，越发现前端其实是巨坑，要学的东西多且杂,而且经常变化，但是我想着我现在才大二，只要我坚持下去，总会是好的。 大一下的时候萌生了弄一个个人博客的想法，想想不错，在博客上面分享自己的想法和记录平时的技术文章和感悟也是相当不错的。暑假一直在查，上网百度，但始终没有方向，因为看不懂，幸运的是，这个学期加了一个新社团，我们的主席，一个超级厉害的人物，给了我们很多干货 ，我觉得能学到的东西非常多，也特别庆幸自己能进到这个社团。然后就在主席的干货中，看到了hexo，发现原来建博客并不是一件难事，尽管如此，我还是捣腾了很多天，当然很大部分原因是因为，我老是没坚持超过2个小时，就去看电视或者玩手机，惭愧啊。 好了，我的博客生活已经开始了，我的博客，还很丑，期待自己后期的完善~~","comments":true,"categories":[],"tags":[{"name":"感想","slug":"感想","permalink":"https://simmon12.github.io/tags/感想/"}]},{"title":"Hello World","date":"2017-02-05T16:28:27.885Z","path":"2017/02/06/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","comments":true,"categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://simmon12.github.io/tags/Hexo/"}]}]