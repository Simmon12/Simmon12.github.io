[{"title":"javascript 练习分析(四)","date":"2017-04-02T11:04:10.000Z","path":"2017/04/02/原型/","text":"对原型练习的理解12345function Ninja() &#123;&#125;var ninja = new Ninja();assert(typeof ninja == \"object\", \"However the type of the instance is still an object\");assert(ninja instanceof Ninja, \"The object was instantiated properly.\");assert(ninja.constructor == Ninja, \"The ninja object was created by the Ninja function\"); 知识点分析1.创建对象之构造函数模式 123456789function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; alert(this.name); &#125;;&#125;var person1 = new Person(\"ss\", 20, \"software Engineer\"); 注意: 函数名Person使用的是大写字母P，按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头，并且构造函数本身也是函数，只不过用于创建对象而已。 创建Person的新实例，必须使用new操作符，若var person1 = Person(), 则person1是undefined。person1对象有一个constructor(构造函数)属性，该属性指向Person。准确来说constructor属性关联的就是当初创建这个对象实例的构造函数。 所以在开篇代码中ninja.constructor == Ninja。 typeof ninja == “object” 其中 typeof是一个操作符，用来测定给定变量的数据类型。 “undefined” — 如果这个值未定义 “boolen” ——–如果这个值是布尔值 “string”———-如果这个值是字符串 “number”——–如果这个值是数字 “object”———-如果这个值是对象或null ”function“——-如果这个值是函数 ninja instanceof Ninja ,其中instanceof运算符用来测试一个对象在其原型链中是否存在一个构造函数的prototype属性. 语法: object instanceof constructor object : 要检测的对象 constructor: 某个构造函数","comments":true,"categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://simmon12.github.io/tags/javascript/"}]},{"title":"javascript练习分析-三","date":"2017-03-21T02:59:20.000Z","path":"2017/03/21/javascript练习分析-三/","text":"Closures(闭包)123456789101112function f1() &#123; var n = 999; nAdd = function() &#123;n+=1&#125; function f2() &#123; alert(n)&#125;; return f2;&#125;var result = f1();result(); // 999;nAdd();result(); //1000;nAdd();result(); //1001; 读书笔记一.闭包是指有权访问另一个函数作用域中的变量的函数，闭包最大的两个用处是：a.可以读取函数内部的变量 b. 让这些变量的值始终保持在内存中.在上面的代码中，result实际上就是闭包函数f2,它一共运行了3次，第一次为999，第二次，第三次一次为1000，1001，这说明了函数f1的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。因为f1是f2的父函数，而f2被赋值给一个全局变量reslut，这导致f2始终在内存中，而f2依赖f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制回收。在第一点的解释中设计到一些知识点，需要了解这些知识点才能更好地了解闭包1.作用域链当代码在一个环境中执行时，会创建变量对象的一个作用域链，其用途是保证对执行环境有权访问的所有变量和函数的有序访问。 作用域的前端，始终都是当前执行的代码所在环境的变量对象，若这个环境是函数，则将其活动对象作为变量对象。作用域链中的下一个变量对象来自包含环境，而再下一个变量对象则来自下一个包含环境，这样一直延续到全局执行环境。标识符解析是沿着作用域链一级一级地搜索标识符地过程，都是从作用域链的前端开始，然后逐级往后，直到找到标识符。注意的是：如果在逐级往后搜索的过程中找到标识符，则马上停止搜索，即如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符。2.变量的作用域(全局变量和局部变量)与C++等语言的重要区别之一是，javascript是没有块级作用域的，即并不是以花括号{}封闭的来拥有自己的作用域，而是以函数function为分界。区分全局变量和局部变量，只需理解这一点: 使用var声明的变量自动被添加到最接近的环境中，而如果初始变量时没有使用var声明，该变量会自动被添加到全局变量 3.垃圾收集机制(后续补充)闭包与变量闭包只能取得包含函数(即外部函数)中任何变量的最后一个值，闭包所保存的是整个变量对象，而不是某个特殊的变量12345678910111213141516171819202122function creatFunction() &#123; var result = new Array(); for (var i = 0; i &lt; 10; i++) &#123; result[i] = function () &#123; return i; &#125;; &#125; return result; //result=[10,10,10,...,10]返回一个都是10的数组，因为每个函数的作用域链中都&#125; //保存着crcreatFunction()函数的活动对象，所以他们引用的都是同一个变量i，crcreatFunction函数返回后，i的值是10； //创建另一个匿名函数强制让闭包的行为符合预期function creatFunction() &#123; var result = new Array(); for(var i = 0; i &lt; 10; i++) &#123; result[i] = function(num) &#123; return function() &#123; return num; &#125; &#125;(i); &#125; return result; //result = [0,1,2,3,4,...9]&#125;","comments":true,"categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://simmon12.github.io/tags/javascript/"}]},{"title":"常见函数模板总结","date":"2017-03-18T03:08:55.000Z","path":"2017/03/18/常见函数模板总结/","text":"判断是否为素数12345678910function isPrime( num ) &#123; var prime = num != 1; //Everything but 1 can be prime for(var i = 2; i &lt; num ; i++) &#123; if(num &amp; i == 0) &#123; prime = false; break; &#125; &#125; return prime;&#125;","comments":true,"categories":[],"tags":[{"name":"template","slug":"template","permalink":"https://simmon12.github.io/tags/template/"}]},{"title":"Javascript练习分析(二)","date":"2017-03-17T06:26:26.000Z","path":"2017/03/17/Javascript练习分析-二/","text":"Function 笔记12345678910111213var ninja = &#123; yell: function(n) &#123; return n &gt; 0 ? ninja.yell(n-1) + \"a\" : \"hiy\"; &#125;&#125;;console.log(ninja.yell(4)) // hiyaaaavar samurai = &#123; yell: ninja.yell &#125;;var ninja = null;try &#123; samurai.yell(4);&#125; catch(e) &#123; console.log(\"mistake\") &#125; //mistake 知识点梳理 一.函数是对象，函数名是指针(是指向函数对象的指针,不会与某个函数绑定)。 换句话说一个函数可能有多个名字。函数的名字仅仅只是一个包含指针的变量而已，因此，计时在不同的环境下执行，全局的某()函数和o.某()函数指向的仍然是同一个函数。二.函数声明提升(function declaration hoisting) 函数声明和函数表达式是存在区别的。解析器会率先读取函数声明，并使其在执行任何代码前可以访问；而函数表达式则必须等到解析器执行到它所在的代码行，才会真正被解释执行 12345678alert(sum1(10,10)); //20function sum1(n1, n2) &#123; return n1 + n2;&#125;alert(sum2(10,10)); // sum2 is not a function 运行错误var sum2 = function(n1, n2) &#123; return n1 + n2;&#125; 三.函数内部有两个特殊的对象，arguments和this。 arguments是一个类数组对象，包含着传入函数中的所有参数。arguments对象有一个叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。在最开始的递归调用代码中，sumurai.yell(4)会调用ninja()函数，但是ninja函数已经变为null，此时调用自然会发生错误。为了消除这种函数名与函数的执行耦合在一起的现象，可以使用arguments.callee。将代码改成如下所示，即可： 12345var ninja = &#123; yell: function(n) &#123; return n &gt; 0 ? arguments.callee(n-1) + 'a' : 'hiy'; //arguments.callee is the function itself. &#125;&#125;; caller这个属性中保存着调用当前函数的函数的引用，即与callee一样也是一个指针，不过caller指向的是调用当前函数的函数。 解决上面问题的第二种方法是给匿名函数命名 12345var ninja = &#123; yell: function yell(n) &#123; return n &gt; 0 ? yell(n-1) + \"a\" : \"hiy\"; &#125;&#125;; 四.重排序方法–reverse()和sort()默认情况下，sort()方法按升序排列数组项(从小到大),为了实现排序，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序，即使数组中的每一项都是数值，sort()方法比较的也是字符串。123var values = [0, 1, 5, 10, 15];values.sort();alert(values); // 0,1,10,15 出现10在5的前面的原因是：虽然数值5小于10，但是在进行字符串比较的时候，”10”位于”5”的前面。可见这种排序方式在很多情况下都不是最佳方案，所以sort()方法可以接收一个比较函数作为参数，以便指定哪个值位于哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则放回0，如果第一个参数应该位于第二个参数之后则返回一个正数。12345678function compare(value1, value2) &#123; if(value1 &lt; value2) return -1; else if(value1 == value2) return 0; else return 1;&#125;var values = [0,1,5,10,15];values.sort(compare);alert(values); //0,1,5,19,15 作为值的函数,函数名本身就是变量，因此可以从一个函数返回另外一个函数123456789101112131415// 可以根据某个对象属性对数组进行排序function createComparsionFunction(propertyName) &#123; return function(object1, object2) &#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; if(value1 &lt; value2) return -1; else if( value1 &gt; value2) return 1; else return 0; &#125;&#125;var data = [&#123;name: \"Zhang\", age: 28&#125;, &#123;name: \"feng\", age: 23&#125;];data.sort(createComparsionFunction(\"name\"));alert(data[0].name); //Zhangdata.sort(createComparsionFunction(\"age\"));alert(data[0].age); //23","comments":true,"categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://simmon12.github.io/tags/javascript/"}]},{"title":"javascript练习分析(一)","date":"2017-03-16T15:42:07.000Z","path":"2017/03/16/javascript练习分析/","text":"理解 Prototype.js的bind()函数fun.bind(this,arg1,arg2)bind()方法会创建一个新的函数，称为绑定函数，fun方法在this环境下调用(这里的this可以绑定到任意对象),该方法可传入连个参数，第一个参数作为this，第二个及以后的参数则作为函数的参数调用123456789// The .bind method from Prototype.jsFunction.prototype.bind = function() &#123; var fn = this, args = Array.prototype.slice.call(arguments), object = args.shift(); return function() &#123; return fn.apply(object, args.concat(Array.prototype.slice.call(arguments)); ) &#125;&#125; 一.Array.slice()和shift()和concat()slice()有两种，一种是string.slice()，另外一种是Array.slice().在数组Array中，slice()能够基于当前数组中的一或多个项创建一个新数组。它可以接受一个或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项，但不包括结束位置的项，注意，slice()方法不会影响原始数组shift()指删除一个数组最前面的值，并且放回删除值.concat()可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前一个数组的副本，然后接收到的参数添加到这个副本的末尾，最后返回新构建的数组。 var colors = [\"red\", \"green\", \"blue\", \"yellow\", \"purple\"]; var color1 = colors.concat(\"yellow\",[\"black\",\"brown\"]); var colors2 = colors.slice(1); var colors3 = colors.slice(1,4); alert(color1); //red,green,blue,yellow,purple,yellow,black,brown alert(colors2); //green,blue,yellow,purple alert(colors3); //green,blue,yellow alert(colors); //red,green,blue,yellow,purple 二.call()和apply()call()和apply()方法主要是用来扩充函数的作用域(把第一个参数作为自己的this)call()和apply()方法接收两个参数:apply():第一个参数是作用域，第二个是参数数组，其中第二个参数可以是数组实例，也可以是arguments对象。call():参数方式与apply一致，区别在于:传参的方式不同，其参数必须逐个写入 三.Array.prototype.slice.call(arguments)arguments是一个关键字，代表当前参数，在Javascript中虽然arguments表面上以数组形式来表示，但实际上没有原生slice的功能，所以要使用call方法算是对arguments对象不完整数组功能的修正。Array.prototype.slice.call(arguments) === Array.prototype.slice.call(arguments,0)Array.prototype.slice调用的是Array的原型方法，对于真正的数组是有slice()方法，但是对于像arguments或者自己定义的一些类数组对象虽然存在length等若干属性，但是并没有slice()方法，所以对于这种类数组对象就得使用原型方法来使用slice()方法，即Array.prototype.slice.(如果在自定义中的类数组对象中自定义了slice()方法，就可以自然地直接调用了)。因此，Array.prototype.slice.call(arguments,0)可以理解为：对于arguments类数组，我们调用Array.prototype.slice原型方法，并用call()方法将作用域限定在arguments中，此时：Array.prototype === arguments, 用参数0位slice()方法中地第一个参数，即开始位置索引，_通过这种方法就将arguments类数组转换位了真数组。 var a = { length: 2, 0: 'first', 1: 'second' }; Array.prototype.slice.call(a); //[\"first\",\"second\"] var a = {length: 2}; Array.prototype.slice.call(a); //[\"undefined\",\"undefined\"]","comments":true,"categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://simmon12.github.io/tags/javascript/"}]},{"title":"图解HTTP","date":"2017-03-05T07:00:59.000Z","path":"2017/03/05/图解HTTP/","text":"《图解HTTP》 读书笔记之网络基础TCP/IP计算机与网络设备要相互通信，双方就必须基于相同的方法，这些方法需要同一种规则，这种规则即称为协议。 像这样把与互联网相关联的协议集合起来总称为TCP/IP。","comments":true,"categories":[],"tags":[{"name":"HTTP协议","slug":"HTTP协议","permalink":"https://simmon12.github.io/tags/HTTP协议/"}]},{"title":"我的第一篇博客","date":"2017-02-07T08:32:48.000Z","path":"2017/02/07/我的第一篇博客/","text":"首先我必须说一点，从小到大我都觉得我的语言组织能力很差，怎么说呢？通常情况下，我会把一件事情说的特别的冗长，后来我仔细地想了想，其实这并不能完全怪我，要怪就得怪那万恶的高考语文作文，说了那么久的废话，我来谈谈正话，其实也不能算是正话，这篇文章的主要目的其实就是随便谈谈而已。 我很开心，为什么呢？因为我终于拥有了一篇属于自己的博客啦，我从大一的时候就一直希望自 己能弄出一个个人网站，因为我想成为一名前端工程师，我想如果我能够熟悉一个网站建立的全过程，我应该就能完整地了解前端后端的全过程，但是我发现这个过程异常的艰辛，偏偏我又是那种很难集中注意力坚持做完一件事的人，我不知道我能不能算是一个有恒心，肯坚持的人，因为一方面我很难坚持完成一件事超过一个小时，另一方面我，我却能长时间地想要完成那件事，我想除了学习，前端应该是我坚持最久的事情。 其实最初接触前端的原因，是因为我觉得它简单，并且前景好，作为一名在计算机专业中的稀有物种，我觉得我必须找到一个适合女生的工作，听到很多师兄师姐，以及网上的评论，说前端比较适合女生，于是乎，就这么开始了，然而越接触，越发现前端其实是巨坑，要学的东西多且杂,而且经常变化，但是我想着我现在才大二，只要我坚持下去，总会是好的。 大一下的时候萌生了弄一个个人博客的想法，想想不错，在博客上面分享自己的想法和记录平时的技术文章和感悟也是相当不错的。暑假一直在查，上网百度，但始终没有方向，因为看不懂，幸运的是，这个学期加了一个新社团，我们的主席，一个超级厉害的人物，给了我们很多干货 ，我觉得能学到的东西非常多，也特别庆幸自己能进到这个社团。然后就在主席的干货中，看到了hexo，发现原来建博客并不是一件难事，尽管如此，我还是捣腾了很多天，当然很大部分原因是因为，我老是没坚持超过2个小时，就去看电视或者玩手机，惭愧啊。 好了，我的博客生活已经开始了，我的博客，还很丑，期待自己后期的完善~~","comments":true,"categories":[],"tags":[{"name":"感想","slug":"感想","permalink":"https://simmon12.github.io/tags/感想/"}]},{"title":"Hello World","date":"2017-02-05T16:28:27.885Z","path":"2017/02/06/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","comments":true,"categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://simmon12.github.io/tags/Hexo/"}]}]