[{"title":"Mpvue采坑记录","date":"2019-04-18T06:32:12.000Z","path":"2019/04/18/Mpvue采坑记录/","text":"Mpvue 采坑记录 授权登录的实现不主动弹窗，需增加登录授权按钮引导用户主动登录授权12345/** 注意需要在getuserinfo前加上@** login是回调事件触发后，即接收到用户信息之后** 才会触发，在e.mp.detail.userInfo中**/ &lt;button class=\"userinfo-nickname\" open-type=\"getUserInfo\" lang=\"zh_CN\" @getuserinfo=\"login\" v-if=\"!logged\"&gt;点我登录&lt;/button&gt; onLoad，mouted，created的实现区别 在vue中，created是按需加载，当我们进入某个页面时，才会加载当前的created；mpvue中，created并不是按需加载，而是一次性把所有页面的created都加载 每一次进入页面都会触发onLoad….. mpvue 中引入iview的坑 引入i-tabs123456789101112131415161718192021&lt;!--微信小程序中--&gt;&lt;i-tabs current=&quot;&#123;&#123; current &#125;&#125;&quot; bindchange=&quot;handleChange&quot;&gt; &lt;i-tab key=&quot;tab1&quot; title=&quot;选项1&quot;&gt;&lt;/i-tab&gt; &lt;i-tab key=&quot;tab2&quot; title=&quot;选项2&quot;&gt;&lt;/i-tab&gt; &lt;i-tab key=&quot;tab3&quot; title=&quot;选项3&quot;&gt;&lt;/i-tab&gt; &lt;/i-tabs&gt;&lt;script&gt;handleChange (&#123; detail &#125;) &#123; this.setData(&#123; current: detail.key &#125;); &#125;,&lt;/script&gt;&lt;!--mpvue中--&gt;&lt;i-tabs :current=&quot;current&quot; @change=&quot;handleChange&quot;&gt; &lt;i-tab key=&quot;menu&quot; title=&quot;目录&quot;&gt;&lt;/i-tab&gt; &lt;i-tab key=&quot;stick&quot; title=&quot;书签&quot;&gt;&lt;/i-tab&gt; &lt;/i-tabs&gt; &lt;script&gt;handleChange (detail) &#123; this.current = detail.mp.detail.key console.log(this.current); &#125;,&lt;/script&gt; &lt;!-- 1. current前要加上: 2. 将bind改为@ 3. 获取key的方式 为 detail.mp.detail.key 微信小程序的缓存微信给每个小程序提供了10M的本地缓存空间","comments":true,"categories":[],"tags":[{"name":"Mpvue","slug":"Mpvue","permalink":"https://simmon12.github.io/tags/Mpvue/"}]},{"title":"ES6学习笔记2","date":"2019-04-18T06:16:05.000Z","path":"2019/04/18/ES6学习笔记2/","text":"ES6学习笔记一. Module的语法 module：es6中一个js文件就是可以成为一个module 如何在一个js文件访问另外一个js文件中的方法和变量使用module的import和export 通过关键字import在一个js文件中引入，无论需要导入变量的个数有多少个，都需要加上{}花括号 通过关键字export将变量/方法导出 二. 模板扩展运算符与模板字符串 ES6语法 模板字符串主要有两种用法 ES6语法 扩展运算符扩展运算符是 … 可以把对象展开， 三. promise异步的方式 回调函数的方式纯粹的回调函数的缺点： 陷入回调地狱，剥夺了函数return的能力 promise (可以解决回调函数的两个缺点)，然而这两种缺点，属于代码风格问题优点：代码风格 多个异步等待合并 不需要层层传递callback async await es2017 但是小程序不支持 promise的用法 promise是一个对象，不是一个函数，a. 对象可以保存状态的，而函数不可以，函数一旦调用，其结果是要被返回的（闭包函数是可以保存变量的）b. promise可以保存状态 pending: 表示异步操作正在进行 ， 一旦用了promise，就处于pending进行中的状态 fulfilled: 异步操作已成功， 通过调用resolve，可以将进行中的状态修改为已成功 rejected: 异步操作已失败，同理，也调用resolve当调用了resolve或者reject函数之后，状态就被凝固了，是无法再变为其他的状态的 new 出的promise的作用可以通过promise这个变量获取异步调用的结果（这就是promise的精髓）第一个参数为，已成功时候的回调函数第二个参数为，已失败的时候的回调函数顺序不能调换，第二个参数可选择传入 promise的精髓在于，通过对象的方式保存了异步回调函数的结果，只需要在需要得到结果的时候，才传入回调函数因此，当进行封装的时候，就不需要每一次都调用回调函数传入，在封装多层的时候，只需要一层层返回promise对象即可。 正确的promise用法并不是在回调函数中嵌套回调函数，是平行的关系，解决了回调地狱的问题 错误的promise使用方法虽然使用了promise，但是还是在回调函数里，调用回调函数 Promise.all 和Promise.race的区别和应用","comments":true,"categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://simmon12.github.io/tags/ES6/"}]},{"title":"小程序学习笔记","date":"2019-04-18T05:39:54.000Z","path":"2019/04/18/小程序学习笔记/","text":"好的代码目录结构 布局：flex 小程序主要使用flex布局 display：flex Flex-direction: column/row 决定了主轴是竖直方向还是垂直方向主轴：有flex-direction决定 Flex 使其变成弹性盒子，flex容器会消除item的块状特性交叉轴：垂直于主轴的方向Justify-content: 主轴的排布对齐方式Align-items: 交叉轴的排布对齐方式小程序尺寸单位与设计原则 设计师建议使用iPhone6作为设计尺寸标准（设计图宽度为750px，高度为667*2） 尺寸图与实际开发的尺寸关系 px/2， rpx 1：1 rpx 相对单位 可随着机型放大缩小，px 是绝对的 大多数可以用rpx，字体用px，border用rpx小程序最重要的就是 布局（flex） 响应（rpx）promise:一. 可以用来解决异步嵌套问题 地狱回调发起了三次的异步回调，并且是在一个异步回调中再发起另一次异步请求当只有一次异步操作，则不需要使用promise promise的写法二. 解决异步函数无法return的问题异步函数被剥夺了return的能力多重封装异步函数的方式获取返回值，不适用promise的方式小程序中的数据数据更新必须通过this.setData({})的方式，不能通过this.data.变量 = xx的方式赋值虽然在data中并没有classic变量，但是通过this.setData的方式会先往this.data中添加新增的变量，然后进行赋值 但是可以养成一个好的习惯，在this.data中标识classic: null(默认值) 小程序中组件的properties和data指向的都是同一个JavaScript对象不要在组件的properties中observer监听函数中修改属性本身的值，否则很可能会引起递归情况 组件的behavior行为当多个组件共用代码，如共用properties，data，或者生命周期函数，小程序提供了一种共用机制 behavior给多个组件定义共同的行为，定义行为的方式和定义一个component的方式是一致的，可以定义属性，方法或者生命周期函数，只是关键字不同而已在组件中的使用方式 组件Component 在小程序中使用缓存机制提高客户体验效果主要思想： 1. 首先在缓存中通过key找到对应的内容 a. 如果找的到，直接从缓存中拿 b. 如果找不到，则通过api的方式获得，并将获得的数据写入缓存中 wx:if和hidden的区别和特性 hidden在自定义组件中是无法隐藏组件的，需要在原生标签中使用（若需要在组件中使用hidden，则可以将hidden作为子组件的属性传递进去，在子组件中的view中使用传进来的hidden值） hidden 组件始终会被渲染，只是简单的控制显示和隐藏 而wx:if是惰性的，若初始渲染条件为false的时候，组件是不会进行渲染的，只有组件渲染条件为true的时候，才会进行渲染，每改变一次渲染条件的时候，组件都会执行一次完整的周期，而hidden是没有的，不会执行完整的周期，只会显示和隐藏。 组件中样式的复用当多个组件应用的样式是一致的时候，可以通过组件复用的方式 小程序中tabBar不同自己实现，直接通过在app.json中配置即可JS 好的代码编写风格github 上搜airbnb 列表循环 小程序中slot插槽的使用在组件中： 在js中先启动slot 在wxml中在父组件中 小程序的开源组件 封装原则 小程序中实现页面(组件中)下拉加载内容 在页面中监听 onReachBottom 事件，改变需要传入组件中的属性 属性使用observer监听传入组件的属性值每次onReachBottom事件发生时，会随机生成字符串 page中 在组件中 解决由于用户下拉速度过快导致发起多个同个请求的问题对锁进行封装，提高代码质量 小程序中获取用户的头像和名称等个人信息在页面中显示用户的信息 open-data, 但是这种方式并无法获取到用户信息，仅仅只是显示当只是需要在页面中显示用户信息的时候，不需要用户授权而需要js获取用户信息的时候，需要通过授权只有当用户授权通过之后，才能调用wx.getUserInfo的方式获取用户信息 在页面中使用组件的时候，若组件的属性是驼峰式的，在页面中会自动在大写字符之前加一个横线","comments":true,"categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://simmon12.github.io/tags/小程序/"}]},{"title":"小程序登录与授权区别","date":"2019-04-18T05:23:34.000Z","path":"2019/04/18/小程序登录与授权区别/","text":"小程序登录与授权区别 微信应用的一个很大的优势就在于使用过程中是不需要进行注册和显式登录的，大部分问题基本上可以一键解决。但是在授权、登录和获取用户信息的过程中都发生了哪些事情， 1.授权和登录的区别 1.1 授权的作用 向用户发起授权请求。调用后会立刻弹窗询问用户是否同意授权小程序使用某项功能或获取用户的某些数据，但不会实际调用对应接口。如果用户之前已经同意授权，则不会出现弹窗，直接返回成功。 也就是说，授权过程实际上只是在小程序前端获得了操作部分wx 接口的访问许可，这个过程实际上是不会与开发者服务器发生任何关系的,以下是允许访问的内容1.2 登录 所谓的登录就是要让开发者服务器知道当前的用户是谁?在传统的web 应用中，我们必须要让用户输入账号和密码才能实现登录操作。但是在微信应用中，我们可以通过微信服务器来完成这个操作，获取到与当前用户对应的唯一标志(openId)，具体操作实现流程如下： 从上图中，我们可以看出，小程序中登录步骤如下：① 小程序前端使用wx.login() 从微信服务器获取code② 小程序前端将code 发送给开发者服务器，开发者服务器利用appId、appSecret 和code 向微信服务器换换取用户openId 和session_key③ 开发者服务器自定义登录态并将其与openId 和session_key 关联起来然后写session④ 开发者服务器将登录态返回给小程序前端，小程序前端使用wx.setStorageSync() 将登录态保存起来⑤ 小程序前端在执行业务请求时将登录态发送给开发者服务器，以便开发者服务器知道当前操作的用户是哪位。也就是说，在整个过程中小程序前端是拿不到用户openId 的，它只能通过开发者服务器发给它的登录态来告诉服务器当前用户的信息。登录过程中涉及session_key 和unionId，于是又引出了下面的问题。 2在应用中如何保存用户登录态保存用户登录态，一直以来都有两种解决方案：前端保存和后端保存。1 后端保存在1.2 步骤③ 中写session 的时候可以直接设定过期时间，定期通知小程序前端重新进行登录(wx.login)。2 前端保存因为session_key 存在时效性问题(毕竟是用来查看敏感信息)，而小程序前端可以通过wx.checkSession() 来检查session_key 是否过期。","comments":true,"categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://simmon12.github.io/tags/小程序/"}]},{"title":"ES6知识点记录","date":"2019-04-18T03:30:28.000Z","path":"2019/04/18/ES6知识点记录/","text":"ES6实战练习之彩票记录一. let 和 const let的生命周期在块作用域（块作用域是指两个括号之间的作用域） let声明的变量不可重复定义 使用const声明的变量是只读的，不可修改 12345678function () &#123; const PI = 3.141; const k = &#123; a:1 &#125; k.b=3; console.log(PI, k)&#125; const声明的对象，对象所在的地址是不可修改的，但是对象的内容是可以被重新赋值和修改的 const声明变量必须同时进行赋值 二. 解构赋值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** ** 解构赋值就是一种左右两边等式的赋值操作 **/// 数组类型的解构赋值&#123; let a, b, rest; [a,b]=[1,2]; console.log(a,b); // a = 1, b = 2;&#125;&#123; let a, b, rest; [a, b, ...rest] = [1, 2, 4, 5, 6]; console.log(a, b, rest); // a = 1, b = 2, rest = [4, 5, 6]&#125;// 对象解构赋值&#123; let a, b; ( &#123;a, b&#125; = &#123;a:1, b:2&#125; console.log(a, b); // 1, 2)&#125;// 默认值, 用于无法匹配成功的情况&#123; let a, b, rest; [a, b,c=3]=[1,2]; console.log(a,b); // a = 1, b = 2;&#125;/****解构赋值的应用**/// 变量的交换，不需要使用中间值&#123; let a = 1; let b =2; [a, b] = [b,a]; console.log(a, b) // 2, 1&#125;// 获取函数返回值&#123; function f() &#123; return [1,2] &#125; let a, b; [a, b] = f(); console.log(a, b)&#125;&#123; function f() &#123; return [1,2,3,4,5] &#125; let a, b, c; [a,,, b] = f(); console.log(a, b); // 1, 4&#125;&#123; function f() &#123; return [1,2,3,4,5] &#125; let a, b, c; [a,,...b] = f(); console.log(a, b); // 1, [3,4,5]&#125;","comments":true,"categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://simmon12.github.io/tags/ES6/"}]},{"title":"js的继承","date":"2018-03-09T13:12:16.000Z","path":"2018/03/09/js的继承/","text":"Javascript 的继承一. 曾经一段时间因为Javascript关于类实现继承的不规范，导致出现了许多实现继承的代码，但实际上，所有的继承方式都是基于以下两种方式:1 通过原型链, 即子类的原型指向父类的实例从而实现原型共享2 借用构造函数, 即通过js的apply(参数)，call(数组)实现子类调用父类的属性，方法原型链方式可以实现所有属性方法共享,但无法做到属性，方法共享(例如Sub1修改了父类的函数(引用类型的值)，其他所有的子类Sub2、Sub3…想调用旧的函数就无法实现了)而借用构造函数除了能独享属性、方法外还能在子类构造函数中传递参数，但代码无法复用。总体而言就是可以实现所有属性方法独享，但无法做到属性、方法共享（例如，Sub1新增了一个函数，然后想让Sub2、Sub3…都可以用的话就无法实现了，只能Sub2、Sub3…各自在构造函数中新增） 二. 组合继承就是把以上两种继承方式一起使用组合继承把共享的属性，方法用原型链继承实现，独享的属性，方法用借用构造函数实现，几乎完美实现了js的继承。但是存在一个缺点：组合继承在实现的时候需要调用两次超类，使得原本父类函数中的属性和方法存在两个地方，一个是在子类的实例上，一个是在子类的原型上，性能不合格 三. 基于组合继承的上述缺点，寄生继承就出现了 寄生继承的思路跟工厂模式差不多，就是调用一个仅用于封装继承过程的函数； 这个继承思路也是由克罗克福德推广的，没错！就是实现那个“原型式继承”的大神。（在很多类库源码中都能发现它的身影）简单而言，寄生继承就是不用实例化父类了，直接实例化一个临时副本实现了相同的原型链继承。（即子类的原型指向父类副本的实例从而实现原型共享）","comments":true,"categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://simmon12.github.io/tags/javascript/"}]},{"title":"vue学习之data","date":"2018-02-11T09:56:08.000Z","path":"2018/02/11/vue学习之data/","text":"data 必须是函数data必须是函数12345&lt;div id=\"example-2\"&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt;&lt;/div&gt; 123456789101112var data = &#123; counter: 0 &#125;Vue.component('simple-counter', &#123; template: '&lt;button v-on:click=\"counter += 1\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', // 技术上 data 的确是一个函数了，因此 Vue 不会警告， // 但是我们却给每个组件实例返回了同一个对象的引用 data: function () &#123; return data &#125;&#125;)new Vue(&#123; el: '#example-2'&#125;) 上面是vue官网给的解释例子，如果data不是一个函数，那么之前所创建的三个组件会共享同一个data对象，因此递增一个counter会影响所有组件，这就会发生错误。我们可以通过为每个组件返回全新的数据对象来修复这个问题12345data: function () &#123; return &#123; counter: 0 &#125;&#125;","comments":true,"categories":[],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://simmon12.github.io/tags/Vue-js/"}]},{"title":"Vue打包上线遇到的坑","date":"2018-02-05T05:47:29.000Z","path":"2018/02/05/Vue打包上线遇到的坑/","text":"vue-cli项目打包出现空白页和路径错误问题对于Vue项目进行打包的时候命令行输入: npm run build 执行完毕后，项目中会出现一个新的文件夹dist, 随后将该文件夹dist放到服务器tomcat的webapps目录下就可以了。 但是，当我直接打开dist文件下的index.html文件的时候，页面完全是空白的，主要是以下两个问题引起的。 1. 文件引用路径错误123456789// 解决方式：到config文件夹中打开index.js文件。// 文件里面有两个assetsPublicPath属性，更改第一个，也就是更改build里面的assetsPublicPath属性：build: &#123; env: require('./prod.env'), index: path.resolve(__dirname, '../dist/index.html'), assetsRoot: path.resolve(__dirname, '../dist'), assetsSubDirectory: 'static', assetsPublicPath: './', // 原本是 '/' 改为'./' productionSourceMap: true, 2. router-view中的内容显示不出来，原因是：路由使用了history模式,这个坑是当你使用了路由之后，在没有后端配合的情况下就手贱打开路由history模式的时候，打包出来的文件也会是一片空白1234567// 解决方式: 将mode: 'history' 注释掉，将这个模式关闭即可let router = new Router(&#123; // mode: 'history', // 如果不配置mode，就会使用默认的hash模式，该模式下会将路径格式化为#！开头 routes: [ &#123; path: '/', redirect: '/home' &#125;, 如果要打开这个模式，必须配置好后端，详情可以看路由配置","comments":true,"categories":[],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://simmon12.github.io/tags/Vue-js/"}]},{"title":"<<Node入门>>书总结","date":"2018-01-26T13:53:47.000Z","path":"2018/01/26/Node入门-书总结/","text":"读《Node.js入门》的笔记 虽然之前曾经用node写过后台，但是node.js究竟是怎样的，我只是会用而已，所以打算开始恶补nodejs，进行系统的学习，所以首先看了《Node.js入门》这本书，原文地址用node.js实现用户上传图片，然后我们将图片显示在浏览器中。完成需要以下四个文件 index.js server.js router.js requestHandles.js index.js1234567891011var server = require('./server');var router = require('./router');var requestHandles = require('./requestHandles');var handle = &#123;&#125;;handle[\"/\"] = requestHandles.start;handle[\"/start\"] = requestHandles.start;handle[\"/upload\"] = requestHandles.upload;handle[\"/show\"] = requestHandles.show;server.start(router.route, handle); server.js1234567891011121314var http = require(\"http\");var url = require(\"url\");function start(route, handle) &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; console.log(\"Requst for \" + pathname + \"received\"); route(handle, pathname, response, request); &#125; http.createServer(onRequest).listen(8888); console.log(\"Server has started\");&#125;exports.start = start; router.js12345678910111213function route(handle, pathname, response, request) &#123; console.log(\"About to route a request for \" + pathname); if(typeof handle[pathname] === 'function') &#123; handle[pathname](response, request); &#125;else &#123; console.log(\"No request handler found for \" + pathname); response.writeHead(404, &#123;\"Content-Type\": \"text/html\"&#125;); response.write(\"404 Not found\"); response.end(); &#125;&#125;exports.route = route; requestHandles.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263var querystring = require(\"querystring\");var fs = require(\"fs\");var formidable = require(\"formidable\");function start(response) &#123; console.log(\"Requst handler 'start' was called\"); var body = '&lt;html&gt;'+ '&lt;head&gt;'+ '&lt;meta http-equiv=\"Content-Type\" content=\"text/html; '+ 'charset=UTF-8\" /&gt;'+ '&lt;/head&gt;'+ '&lt;body&gt;'+ '&lt;form action=\"/upload\" enctype=\"multipart/form-data\" '+ 'method=\"post\"&gt;'+ '&lt;input type=\"file\" name=\"upload\" multiple=\"multiple\"&gt;'+ '&lt;input type=\"submit\" value=\"Upload file\" /&gt;'+ '&lt;/form&gt;'+ '&lt;/body&gt;'+ '&lt;/html&gt;'; response.writeHead(200, &#123;\"Content-Type\": \"text/html\"&#125;); response.write(body); response.end();&#125;function upload(response, request) &#123; console.log(\"about to parse\"); var form = new formidable.IncomingForm(); form.uploadDir = 'tmp'; console.log(\"about to parse\"); form.parse(request, function(error, fields, files) &#123; console.log(\"parsing done\"); fs.renameSync(files.upload.path, \"./tmp/test.png\"); //var readStream = fs.createReadStream(files.upload.path); //var writeStream = fs.createWriteStream(\"./tmp/test.png\"); //readStream.pipe(writeStream); //readStream.on('end', function() &#123; // fs.unlinkSync(files.upload.path); //&#125;) response.writeHead(200, &#123;\"Content-Type\":\"text/html\"&#125;); response.write(\"received image:&lt;br/&gt;\"); response.write(\"&lt;img src='/show'/&gt;\"); response.end(); &#125;);&#125;function show(response) &#123; console.log(\"Requst handler 'show' was called\"); fs.readFile(\"./tmp/test.png\", \"binary\", function(error, file) &#123; if(error) &#123; response.writeHead(500,&#123;\"Content-Type\":\"text/plain\"&#125;); response.write(error + \"\\n\"); response.end(); &#125;else &#123; response.writeHead(200, &#123;\"Content-Type\": \"image/png\"&#125;); response.write(file, \"binary\"); response.end(); &#125; &#125;);&#125;exports.start = start;exports.upload = upload;exports.show = show; 上传文件部分常见问题在处理函数upload中，直接调用fs.renameSync方法会发生以下错误原因是：跨磁盘分区移动或者操作文件会有权限问题。 有两种解决方法第一种：主要利用fs的createReadStream、createWriteSream和unlinkSync方法12345678910111213141516171819function upload(response, request) &#123; console.log(\"about to parse\"); var form = new formidable.IncomingForm(); console.log(\"about to parse\"); form.parse(request, function(error, fields, files) &#123; console.log(\"parsing done\"); // fs.renameSync(files.upload.path, \"./tmp/test.png\"); var readStream = fs.createReadStream(files.upload.path); var writeStream = fs.createWriteStream(\"./tmp/test.png\"); readStream.pipe(writeStream); readStream.on('end', function() &#123; fs.unlinkSync(files.upload.path); &#125;) response.writeHead(200, &#123;\"Content-Type\":\"text/html\"&#125;); response.write(\"received image:&lt;br/&gt;\"); response.write(\"&lt;img src='/show'/&gt;\"); response.end(); &#125;);&#125; 第二种 添加一个 form.uploadDir=’tmp’ 即可（写一个临时路径）1234567891011121314function upload(response, request) &#123; console.log(\"about to parse\"); var form = new formidable.IncomingForm(); form.uploadDir = 'tmp'; console.log(\"about to parse\"); form.parse(request, function(error, fields, files) &#123; console.log(\"parsing done\"); fs.renameSync(files.upload.path, \"./tmp/test.png\"); response.writeHead(200, &#123;\"Content-Type\":\"text/html\"&#125;); response.write(\"received image:&lt;br/&gt;\"); response.write(\"&lt;img src='/show'/&gt;\"); response.end(); &#125;);&#125;","comments":true,"categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://simmon12.github.io/tags/Node-js/"}]},{"title":"大三寒假","date":"2018-01-23T07:36:09.000Z","path":"2018/01/23/大三寒假/","text":"","comments":true,"categories":[],"tags":[]},{"title":"JavaScript this决策树","date":"2017-12-19T03:13:15.000Z","path":"2017/12/19/JavaScript-this决策树/","text":"Javascript this 到底指向什么？ 前几天看了一篇技术博客，里面通过使用Javascript决策树的方式讲述了this的指向问题，看完之后收益匪浅，觉得一定要好好地记录下来作笔记，原文地址 不同于现在一些主流的面向对象的语言(比如java和c++)this含义是明确且确定的，this指向的都是当前对象，并且在编译时期就绑定了。而JavaScript中的this是在运行期进行绑定的，因此，在不同的场景下，Js中的this所指向的对象是不同的。 当函数的调用方式不同的时候，JavaScript中this不同，可以是全局对象，当前对象或者是任意的对象。JavaScript中函数调用的几种方式：作为对象方法调用，作为函数调用，作为构造函数调用，使用apply或call调用。作者用了一张决策树图表解释了JavaScript this到底指向什么？ 例子：12345678var point = &#123; x: 0, y: 0, moveTo: function(x,y) &#123; this.x = this.x + x; this.y = this.y + y; &#125;&#125; point.moveTo()函数在“Javascript this 决策树”中的判定过程为： point.moveTo函数调用是用new进行调用么？不是，进入否分支， point.moveTo函数是用dot(.)进行调用的吗？是，进入是分支，所以这里的this指向dot之前的对象point, this.x实际上是point.x 1234function func(x)&#123; this.x=x;&#125;func(5); func(5)函数调用是用new进行调用吗？不是，进入否分支 func(5)函数调用是用dot(.)进行调用吗？否，进入否分支，所以这里的this指向全局变量window, 即this.x实际上是window.x 123456789101112131415161718192021var point = &#123; x: 0, y: 0, moveTo: function(x, y) &#123; //内部函数 var moveX = function(x) &#123; this.x = x; // this指向window &#125;; // 内部函数 var moveY = function(y) &#123; this.y = y; // this指向window &#125;; moveX(x); moveY(y); &#125;&#125;;point.moveTo(1,1);point.x; // =&gt;0point.y; // =&gt;0x; // =&gt;1;y; // =&gt;1 point.moveTo(1,1)函数内部调用的是moveX()和moveY()函数，这两个函数中的this指向判定过程 moveX(1)函数调用是用new进行调用的么？不是，进入否分支 moveX(1)函数使用用dot进行调用的吗，否，进入否分支，所以this指向全局window，所以this.x 实际上是window.x; 下面看一个作为构造函数调用的例子123456789function Point(x, y) &#123; this.x = x; // this ? this.y = y; // this ? &#125;var np = new Point(1, 1);np.x; // 1var p = Point(2,2);p.x; // error p是一个空对象undefinedwindow.x // 2 Point(1,1)函数在 var np = new Point(1,1)中this的决策过程 var np = new Point(1,1)调用时用new调用么？是，进入是分支，this指向np 所以这里this.x = np.x = 1; Point(2,2)在决策树的判决过程 var p = Point(2, 2)调用是用new 进行调用么？不是，进入否分支， 上述是用dot调用么？不是，进入否分支，所以this指向window，所以this.x = 2, 也就是window.x = 2 最后是一个函数用call和apply进行调用的例子123456789101112function Point(x, y) &#123; this.x = x; this.y = y; this.moveTo = function(x, y) &#123; this.x = x; this.x = y; &#125;&#125;var p1 = new Point(0, 0);var p2 = &#123;x:0, y: 0&#125;;p1.moveTo.apply(p2, [10,10]); // apply实际上为p2.moveTo(10,10)p2.x; // 10 p1.moveTo.apply(p2, [10,10])函数在”Javascript this 决策树”中进行判定的过程首选，apply和call这两个方法异常强大，允许切换函数执行的上下文环境(context)， 即this绑定的对象。p1.moveTo.apply(p2, [10,10])实际上是p2.moveTo(10,10)，那么p2.moveTo(10,10)可解释为： p2.moveTo(10,10)函数调用时用new进行调用吗？不是，进入“否”分支 函数是用dot调用吗是，进入是分支，这里的this指向dot前的对象p2, 所以 p2.x =10; 原作者说道理解下一段话对于理解Javascript函数有很大的作用 Javascript中的函数既可以被当做普通函数执行，也可以作为对象的方法执行，这是导致this含义如此丰富的主要原因。一个函数被执行的时候，会创建一个执行环境，函数的所有的行为均发生在此执行环境中，构建该执行环境时，JavaScript首先会创建arguments变量，其中包含调用函数时传入的参数。接下来创建作用域链。然后初始化变量，首先初始化函数的形参表，值为arguments变量中对应的值，如果arguments变量中没有对应值，则该形参初始化为undefined。如果该函数中含有内部函数，则初始化这些内部函数，如果没有，继续初始化该函数内定义的局部变量，需要注意的是此时这些变量初始化为undefined，其赋值操作在执行环境创建成功后，函数执行时才会执行，这点对于我们理解Javascript中的变量作用域非常重要，最后为this变量赋值，如前所述，会根据函数调用方式的不同，赋给this全局对象，当前对象等。至此，函数的执行环境创建成功，函数开始逐行执行，所需变量均从之前构建好的执行环境中读取。","comments":true,"categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://simmon12.github.io/tags/javascript/"}]},{"title":"大三上WEB Project项目总结","date":"2017-12-19T02:12:35.000Z","path":"2017/12/19/大三上WEBProject项目总结/","text":"基于Java web的电影影评网站 点此获得源码和实验报告 这次的项目是和队友一起合作完成，主要涉及到的技术栈如下 jsp页面 数据库使用的是MySQL 项目存在的优缺点 优点：前端的实现为原生，但是很多好的样式是copy网上代码的，比如涉及CSS sticky footer使得footer能永远在内容的最底部，怎么做到的呢，课后必须花时间学习。登陆框，注册框，遮罩层的样式也是基本用了网上的代码，必须后面自己学习，电影详情页的海报样式必须自学。后端拦截也实现了，md5密码加密 缺点：主页登录注册部分每次按按钮都是重新加载页面， 不好，没有做到异步刷新，同样电影详情的评论也没有做到局部刷新和异步更新，增加电影页面用户交互感不好，没有错误提示 思考 这一次的前端没有使用框架，感觉没有使用框架，原生的方式实现并没有想象中困难，然而当用上框架的时候，不论是vue，angular，Jquery，在一定程度上都会有些冗余，以前在使用框架的时候，没有想明白为什么要使用框架，只是在学习的过程中看到网上的人总结说框架能简化开发，把重心多放在逻辑上，但是我并没有太多的这种感觉，尤其是这一次，我突然很想问：为什么存在前端框架？ jsp的优缺点： jsp = html+java，jsp与Java Servlet一样在服务器端执行，通常返回客户端一个html文本(JSP页面由HTML代码和嵌入其中的Java代码所组成。服务器在页面被客户端请求以后对这些Java代码进行处理，然后将生成的HTML页面返回给客户端的浏览器) 缺点：JSP运行将java代码插入到html中，使得内容能混合到表示上，业务逻辑也会进入到jsp页面中 后期改进 用nodejs做后端，mongodb做数据库，实现前后端分离。","comments":true,"categories":[],"tags":[{"name":"项目总结","slug":"项目总结","permalink":"https://simmon12.github.io/tags/项目总结/"}]},{"title":"MVVM框架","date":"2017-10-21T03:50:53.000Z","path":"2017/10/21/MVVM框架/","text":"MVVM框架笔记 MVVM的英文全称为：Model-View-ViewModel 核心为：数据模型的数据双向绑定 主要包括一下三个部分 ViewModel作为观察者的角色： 当Model层数据发生变化，ViewModel能观察到数据发生的变化，然后通知对于的视图View作出变化 当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据Model作变动 通过上述两种方式，实现 数据的双向绑定 MVVM框架的优点 针对有复杂交互逻辑的前端应用，可以省去许多手动触发DOM操作 通过Ajax数据持久化，可以进行局部刷新 常见的MVVM框架有：Angular.js , react.js vue.js","comments":true,"categories":[],"tags":[]},{"title":"thought","date":"2017-09-23T04:56:00.000Z","path":"2017/09/23/thought/","text":"记大三上一个雨后的中午广州的天气和往常一般调皮，毫无征兆地下雨，毫无征兆地停雨。我已经在这个世界留下了20年的痕迹，想起自己身边的人，小学，初中，高中，我们曾经呆在同一间教室，曾经困扰于同一道解析几何题，然而步入大学之后，就好像到了一个分岔路口，每个人似乎都朝着自己的方向渐行渐远。","comments":true,"categories":[],"tags":[{"name":"感想","slug":"感想","permalink":"https://simmon12.github.io/tags/感想/"}]},{"title":"响应式设计(一)","date":"2017-09-07T15:33:34.000Z","path":"2017/09/07/响应式设计/","text":"响应式网站的概念 流动网格，弹性图片和媒介查询是响应式设计的三大技术成分，但是崭新的思路也是必不可少的。与其把同样的内容割裂成不同设备专属的体验，我们可以通过媒介查询，渐进增强式地将一个设计在不同的阅读环境中加以优化。这么说并不是要绝对否定在任何情况下使用针对特定设备的独立网站，比如当移动用户在你的网站上的商业目的相比固定电脑用户要单一得多的时候，为两种情况分别输送不同的内容可能是最好的方法。然而我们也不需要固守在那样的设计思路里。如今越来越需要我们的设计能够呈现在一系列多种多样的体验中。响应式设计为我们指出了一条未来的路，是我们终于可以依照万物生灭的规律来进行设计了。来自: Responsive Web Design作者：伊森·马考特（Ethan Marcotte）https://site.douban.com/186898/widget/notes/10926516/note/241877629/ 响应式网站的组成 flexible grid layout 弹性网格布局 flexible image 弹性图片 media queries 媒介查询 常用的简单的可缩放的布局方式1234567.container &#123; width: 100%;&#125;.content &#123; width: 90%; margin: 2px auto;&#125; 在设置内容width属性的时候，不要直接设定特定的像素大小，而是通过百分比的方式，这样，当页面进行缩放的时候，宽度不会死死的固定，样式更加整体化和灵活。 媒介查询在CSS2中12&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"site.css\" media=\"screen\"/&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"print.css\" media=\"print\"/&gt; 在CSS3中1234@media all and (min-width: 800px) and (orientation: landscape) &#123; ......&#125;// all 可以是各种媒体设备，也可以是screen等，当只是针对某种设备的时候，为了兼容老的浏览器，最好在媒体设备前加上only，当and后面的表达式为真的时候，括号里的样式才会显示出来 viewport 视口 width：视口宽度 device-width: 设备屏幕的宽度 在桌面浏览器的时候，视口指的是浏览器主窗口的区域。在手机浏览器中，会出现3个视口概念 布局视口: 默认大小是厂商的值，一般为960px 可视视口（缩放时，可视视口是会发生改变的，默认是手机屏幕的大小） 理想视口：理想视口是布局视口在一个设备上的最佳尺寸，理想视口下的页面便于浏览器浏览阅读，不需要进行缩放。实现理想视口：（在响应式网站中最起码要有以下的语句）1&lt;meta name=\"viewport\" content=\"width=device-width\"/&gt; 用户在手机上不用进行缩放，体验会非常好，有一些甚至会禁止缩放如百度1234&lt;meta name=\"viewport\" content=\"width=device-width,minimum-scale = 1.0, //最小的缩放比例 maximum-scale = 1.0, // 最大的缩放比例user-scalable = no\"/&gt; // 禁用了用户缩放 em, rem, px一. px二. em 一种相对的长度单位，更加适合响应式设计 em相对的参照物为父元素的font-size 当一直向上找到html都没有设置font-size的时候，浏览器会有一个默认的em设置： 1em = 16px三. rem的相对参照物为根元素html，相于参照固定不变，所以好算，同样当没有设置font-size时，浏览器会有一个默认的rem设置：1rem = 16px一些单位的转换 font-size: 62.5% 1rem = 10px (10/16*100%) font-size: 100% 1rem = 16px 响应式图片一. 滚动式组件推荐（OwlCarousel2）二. 挑选第三方组件的标准 使用人数 是否开源 文档是否齐全 活跃性 小巧够用的组件（轻量级）三. 实现响应式图片的方式 js或服务端1234567891011121314$(document).ready(function() &#123; function makeImageResponsive() &#123; var width = $(window).width(); var img = $('.content img'); if (width &lt;= 480) &#123; img.attr('src', 'img/480.png'); &#125; else if (width &lt;= 800) &#123; img.attr('src': 'img/800.png'); &#125; else &#123; img.attr('src': 'img/1600.png'); &#125; &#125; $(window).on('resize load': makeImageResponsive);&#125;) 属于命令性的实现 srcset配合sizes 123&lt;img class=\"image\" src=\"img/480.png\" srcset = \"img/480.png 480w, img/800.png 800w, img/1600.png 1600w\" sizes=\"x\"&gt; x的值是包含这张图片的div的大小(50% 50vw, 50px 50px) picture（使用picturefill.min.js填补一些浏览器不支持picture标签的坑） 12345&lt;picture&gt; &lt;source srcset=\"img/ad001-l.png\" media=\"(min-width: 50em)\"&gt; &lt;source srcset=\"img/ad001-m.png\" media=\"(min-width: 30em)\"&gt; &lt;img src=\"img/ad001.png\" alt=\"2015年度报告\"&gt;&lt;/picture&gt; svg 压缩图片的网站地址https://tinyping.com做网站时，尤其是从设计师哪来的图片，通过压缩，可以提升页面载入速度，有时候可能会比优化代码时提升的速度还要快。","comments":true,"categories":[],"tags":[{"name":"响应式","slug":"响应式","permalink":"https://simmon12.github.io/tags/响应式/"}]},{"title":"随笔","date":"2017-04-17T02:08:39.000Z","path":"2017/04/17/随笔/","text":"忙碌的大二，迷茫的内心 忙里偷闲的一次博客，其实我是没有时间来写这篇博客的，我觉得写完这篇博客，也许就到了吃饭时间，这样本可以用来做OS实验的时间就没了，但是我还是选择了写博客，不为别的，只为写写自己所想所思的，清明的时候没有回家，呆在学校呆了3天，每天学学习，看看剧，偶尔睡睡午觉，偷偷懒，这种生活很惬意。去外面剪了个头发，与之前不同的是剪了个刘海，想说换换心情，换换形象。但是好像中分已经稳固地不能撼动了，刘海老是中分，导致出现此刻用笔盖夹刘海的我，可能之前有刘海的时光再也回不去了，就好像小时候那种学校出游前一晚那种激动兴奋的心情再也体会不到一样，有时候想想真的很难过。我的大二异常地忙碌，每天不是在做实验，就是在写报告的路上，我好像收获了很多，又好像并没有得到些什么，自己想学的东西，没学，看到别人的努力和认真，自己很羡慕很嫉妒，然而自己却没作出半点尝试，身边的人很优秀，自己很渣，但是换另外一个角度想想，我在一些人的眼里是不是或许也是优秀的人。但是我换不了角度，很多人说，要自信，要乐观，不要老是在意别人的目光，不要老是看别人，但是这些都只是说，谁能做到，说的好听，做的难。所以我有时候不懂得怎么去安慰别人，我连自己都安慰不了，怎么安慰别人，我说不出那些大道理，因为我做不到。这个星期又有一大堆实验，各种ddl又来了，又是各种熬夜，上星期天气冷，下了个水，就发烧了，感觉自己弱爆了。果然熬夜不行啊！！！我不想每次都找借口，前端还有一大堆的东西没学呢！！！","comments":true,"categories":[],"tags":[{"name":"感想","slug":"感想","permalink":"https://simmon12.github.io/tags/感想/"}]},{"title":"Git","date":"2017-04-06T16:59:13.000Z","path":"2017/04/07/Git/","text":"Windows下Git的安装和使用详细教程： http://blog.jobbole.com/78960/ Linux下Git的安装和使用详细教程: http://www.cnblogs.com/20145335hh/p/5954564.html","comments":true,"categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://simmon12.github.io/tags/Git/"}]},{"title":"javascript 练习分析(四)","date":"2017-04-02T11:04:10.000Z","path":"2017/04/02/原型/","text":"对原型练习的理解12345function Ninja() &#123;&#125;var ninja = new Ninja();assert(typeof ninja == \"object\", \"However the type of the instance is still an object\");assert(ninja instanceof Ninja, \"The object was instantiated properly.\");assert(ninja.constructor == Ninja, \"The ninja object was created by the Ninja function\"); 知识点分析 1.创建对象之构造函数模式 123456789function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; alert(this.name); &#125;;&#125;var person1 = new Person(\"ss\", 20, \"software Engineer\"); 注意: 函数名Person使用的是大写字母P，按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头，并且构造函数本身也是函数，只不过用于创建对象而已。 创建Person的新实例，必须使用new操作符，若var person1 = Person(), 则person1是undefined。person1对象有一个constructor(构造函数)属性，该属性指向Person。准确来说constructor属性关联的就是当初创建这个对象实例的构造函数。 所以在开篇代码中ninja.constructor == Ninja。 typeof ninja == “object” 其中 typeof是一个操作符，用来测定给定变量的数据类型。 “undefined” — 如果这个值未定义 “boolen” ——–如果这个值是布尔值 “string”———-如果这个值是字符串 “number”——–如果这个值是数字 “object”———-如果这个值是对象或null ”function“——-如果这个值是函数 ninja instanceof Ninja ,其中instanceof运算符用来测试一个对象在其原型链中是否存在一个构造函数的prototype属性. 语法: object instanceof constructor object : 要检测的对象 constructor: 某个构造函数","comments":true,"categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://simmon12.github.io/tags/javascript/"}]},{"title":"javascript练习分析-三","date":"2017-03-21T02:59:20.000Z","path":"2017/03/21/javascript练习分析-三/","text":"Closures(闭包)123456789101112function f1() &#123; var n = 999; nAdd = function() &#123;n+=1&#125; function f2() &#123; alert(n)&#125;; return f2;&#125;var result = f1();result(); // 999;nAdd();result(); //1000;nAdd();result(); //1001; 读书笔记一.闭包是指有权访问另一个函数作用域中的变量的函数，闭包最大的两个用处是：a.可以读取函数内部的变量 b. 让这些变量的值始终保持在内存中.在上面的代码中，result实际上就是闭包函数f2,它一共运行了3次，第一次为999，第二次，第三次一次为1000，1001，这说明了函数f1的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。因为f1是f2的父函数，而f2被赋值给一个全局变量reslut，这导致f2始终在内存中，而f2依赖f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制回收。在第一点的解释中设计到一些知识点，需要了解这些知识点才能更好地了解闭包1.作用域链当代码在一个环境中执行时，会创建变量对象的一个作用域链，其用途是保证对执行环境有权访问的所有变量和函数的有序访问。 作用域的前端，始终都是当前执行的代码所在环境的变量对象，若这个环境是函数，则将其活动对象作为变量对象。作用域链中的下一个变量对象来自包含环境，而再下一个变量对象则来自下一个包含环境，这样一直延续到全局执行环境。标识符解析是沿着作用域链一级一级地搜索标识符地过程，都是从作用域链的前端开始，然后逐级往后，直到找到标识符。注意的是：如果在逐级往后搜索的过程中找到标识符，则马上停止搜索，即如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符。2.变量的作用域(全局变量和局部变量)与C++等语言的重要区别之一是，javascript是没有块级作用域的，即并不是以花括号{}封闭的来拥有自己的作用域，而是以函数function为分界。区分全局变量和局部变量，只需理解这一点: 使用var声明的变量自动被添加到最接近的环境中，而如果初始变量时没有使用var声明，该变量会自动被添加到全局变量 3.垃圾收集机制(后续补充)闭包与变量闭包只能取得包含函数(即外部函数)中任何变量的最后一个值，闭包所保存的是整个变量对象，而不是某个特殊的变量12345678910111213141516171819202122function creatFunction() &#123; var result = new Array(); for (var i = 0; i &lt; 10; i++) &#123; result[i] = function () &#123; return i; &#125;; &#125; return result; //result=[10,10,10,...,10]返回一个都是10的数组，因为每个函数的作用域链中都&#125; //保存着crcreatFunction()函数的活动对象，所以他们引用的都是同一个变量i，crcreatFunction函数返回后，i的值是10； //创建另一个匿名函数强制让闭包的行为符合预期function creatFunction() &#123; var result = new Array(); for(var i = 0; i &lt; 10; i++) &#123; result[i] = function(num) &#123; return function() &#123; return num; &#125; &#125;(i); &#125; return result; //result = [0,1,2,3,4,...9]&#125;","comments":true,"categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://simmon12.github.io/tags/javascript/"}]},{"title":"常见函数模板总结","date":"2017-03-18T03:08:55.000Z","path":"2017/03/18/常见函数模板总结/","text":"判断是否为素数12345678910function isPrime( num ) &#123; var prime = num != 1; //Everything but 1 can be prime for(var i = 2; i &lt; num ; i++) &#123; if(num &amp; i == 0) &#123; prime = false; break; &#125; &#125; return prime;&#125;","comments":true,"categories":[],"tags":[{"name":"template","slug":"template","permalink":"https://simmon12.github.io/tags/template/"}]},{"title":"Javascript练习分析(二)","date":"2017-03-17T06:26:26.000Z","path":"2017/03/17/Javascript练习分析-二/","text":"Function 笔记12345678910111213var ninja = &#123; yell: function(n) &#123; return n &gt; 0 ? ninja.yell(n-1) + \"a\" : \"hiy\"; &#125;&#125;;console.log(ninja.yell(4)) // hiyaaaavar samurai = &#123; yell: ninja.yell &#125;;var ninja = null;try &#123; samurai.yell(4);&#125; catch(e) &#123; console.log(\"mistake\") &#125; //mistake 知识点梳理 一.函数是对象，函数名是指针(是指向函数对象的指针,不会与某个函数绑定)。 换句话说一个函数可能有多个名字。函数的名字仅仅只是一个包含指针的变量而已，因此，计时在不同的环境下执行，全局的某()函数和o.某()函数指向的仍然是同一个函数。二.函数声明提升(function declaration hoisting) 函数声明和函数表达式是存在区别的。解析器会率先读取函数声明，并使其在执行任何代码前可以访问；而函数表达式则必须等到解析器执行到它所在的代码行，才会真正被解释执行 12345678alert(sum1(10,10)); //20function sum1(n1, n2) &#123; return n1 + n2;&#125;alert(sum2(10,10)); // sum2 is not a function 运行错误var sum2 = function(n1, n2) &#123; return n1 + n2;&#125; 三.函数内部有两个特殊的对象，arguments和this。 arguments是一个类数组对象，包含着传入函数中的所有参数。arguments对象有一个叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。在最开始的递归调用代码中，sumurai.yell(4)会调用ninja()函数，但是ninja函数已经变为null，此时调用自然会发生错误。为了消除这种函数名与函数的执行耦合在一起的现象，可以使用arguments.callee。将代码改成如下所示，即可： 12345var ninja = &#123; yell: function(n) &#123; return n &gt; 0 ? arguments.callee(n-1) + 'a' : 'hiy'; //arguments.callee is the function itself. &#125;&#125;; caller这个属性中保存着调用当前函数的函数的引用，即与callee一样也是一个指针，不过caller指向的是调用当前函数的函数。 解决上面问题的第二种方法是给匿名函数命名 12345var ninja = &#123; yell: function yell(n) &#123; return n &gt; 0 ? yell(n-1) + \"a\" : \"hiy\"; &#125;&#125;; 四.重排序方法–reverse()和sort()默认情况下，sort()方法按升序排列数组项(从小到大),为了实现排序，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序，即使数组中的每一项都是数值，sort()方法比较的也是字符串。123var values = [0, 1, 5, 10, 15];values.sort();alert(values); // 0,1,10,15 出现10在5的前面的原因是：虽然数值5小于10，但是在进行字符串比较的时候，”10”位于”5”的前面。可见这种排序方式在很多情况下都不是最佳方案，所以sort()方法可以接收一个比较函数作为参数，以便指定哪个值位于哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则放回0，如果第一个参数应该位于第二个参数之后则返回一个正数。12345678function compare(value1, value2) &#123; if(value1 &lt; value2) return -1; else if(value1 == value2) return 0; else return 1;&#125;var values = [0,1,5,10,15];values.sort(compare);alert(values); //0,1,5,19,15 作为值的函数,函数名本身就是变量，因此可以从一个函数返回另外一个函数123456789101112131415// 可以根据某个对象属性对数组进行排序function createComparsionFunction(propertyName) &#123; return function(object1, object2) &#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; if(value1 &lt; value2) return -1; else if( value1 &gt; value2) return 1; else return 0; &#125;&#125;var data = [&#123;name: \"Zhang\", age: 28&#125;, &#123;name: \"feng\", age: 23&#125;];data.sort(createComparsionFunction(\"name\"));alert(data[0].name); //Zhangdata.sort(createComparsionFunction(\"age\"));alert(data[0].age); //23","comments":true,"categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://simmon12.github.io/tags/javascript/"}]},{"title":"javascript练习分析(一)","date":"2017-03-16T15:42:07.000Z","path":"2017/03/16/javascript练习分析/","text":"理解 Prototype.js的bind()函数fun.bind(this,arg1,arg2)bind()方法会创建一个新的函数，称为绑定函数，fun方法在this环境下调用(这里的this可以绑定到任意对象),该方法可传入连个参数，第一个参数作为this，第二个及以后的参数则作为函数的参数调用123456789// The .bind method from Prototype.jsFunction.prototype.bind = function() &#123; var fn = this, args = Array.prototype.slice.call(arguments), object = args.shift(); return function() &#123; return fn.apply(object, args.concat(Array.prototype.slice.call(arguments)); ) &#125;&#125; 一.Array.slice()和shift()和concat()slice()有两种，一种是string.slice()，另外一种是Array.slice().在数组Array中，slice()能够基于当前数组中的一或多个项创建一个新数组。它可以接受一个或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项，但不包括结束位置的项，注意，slice()方法不会影响原始数组shift()指删除一个数组最前面的值，并且放回删除值.concat()可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前一个数组的副本，然后接收到的参数添加到这个副本的末尾，最后返回新构建的数组。 var colors = [\"red\", \"green\", \"blue\", \"yellow\", \"purple\"]; var color1 = colors.concat(\"yellow\",[\"black\",\"brown\"]); var colors2 = colors.slice(1); var colors3 = colors.slice(1,4); alert(color1); //red,green,blue,yellow,purple,yellow,black,brown alert(colors2); //green,blue,yellow,purple alert(colors3); //green,blue,yellow alert(colors); //red,green,blue,yellow,purple 二.call()和apply()call()和apply()方法主要是用来扩充函数的作用域(把第一个参数作为自己的this)call()和apply()方法接收两个参数:apply():第一个参数是作用域，第二个是参数数组，其中第二个参数可以是数组实例，也可以是arguments对象。call():参数方式与apply一致，区别在于:传参的方式不同，其参数必须逐个写入 三.Array.prototype.slice.call(arguments)arguments是一个关键字，代表当前参数，在Javascript中虽然arguments表面上以数组形式来表示，但实际上没有原生slice的功能，所以要使用call方法算是对arguments对象不完整数组功能的修正。Array.prototype.slice.call(arguments) === Array.prototype.slice.call(arguments,0)Array.prototype.slice调用的是Array的原型方法，对于真正的数组是有slice()方法，但是对于像arguments或者自己定义的一些类数组对象虽然存在length等若干属性，但是并没有slice()方法，所以对于这种类数组对象就得使用原型方法来使用slice()方法，即Array.prototype.slice.(如果在自定义中的类数组对象中自定义了slice()方法，就可以自然地直接调用了)。因此，Array.prototype.slice.call(arguments,0)可以理解为：对于arguments类数组，我们调用Array.prototype.slice原型方法，并用call()方法将作用域限定在arguments中，此时：Array.prototype === arguments, 用参数0位slice()方法中地第一个参数，即开始位置索引，_通过这种方法就将arguments类数组转换位了真数组。 var a = { length: 2, 0: 'first', 1: 'second' }; Array.prototype.slice.call(a); //[\"first\",\"second\"] var a = {length: 2}; Array.prototype.slice.call(a); //[\"undefined\",\"undefined\"]","comments":true,"categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://simmon12.github.io/tags/javascript/"}]},{"title":"图解HTTP","date":"2017-03-05T07:00:59.000Z","path":"2017/03/05/图解HTTP/","text":"《图解HTTP》 读书笔记之网络基础TCP/IP计算机与网络设备要相互通信，双方就必须基于相同的方法，这些方法需要同一种规则，这种规则即称为协议。 像这样把与互联网相关联的协议集合起来总称为TCP/IP。","comments":true,"categories":[],"tags":[{"name":"HTTP协议","slug":"HTTP协议","permalink":"https://simmon12.github.io/tags/HTTP协议/"}]},{"title":"我的第一篇博客","date":"2017-02-07T08:32:48.000Z","path":"2017/02/07/我的第一篇博客/","text":"首先我必须说一点，从小到大我都觉得我的语言组织能力很差，怎么说呢？通常情况下，我会把一件事情说的特别的冗长，后来我仔细地想了想，其实这并不能完全怪我，要怪就得怪那万恶的高考语文作文，说了那么久的废话，我来谈谈正话，其实也不能算是正话，这篇文章的主要目的其实就是随便谈谈而已。 我很开心，为什么呢？因为我终于拥有了一篇属于自己的博客啦，我从大一的时候就一直希望自 己能弄出一个个人网站，因为我想成为一名前端工程师，我想如果我能够熟悉一个网站建立的全过程，我应该就能完整地了解前端后端的全过程，但是我发现这个过程异常的艰辛，偏偏我又是那种很难集中注意力坚持做完一件事的人，我不知道我能不能算是一个有恒心，肯坚持的人，因为一方面我很难坚持完成一件事超过一个小时，另一方面我，我却能长时间地想要完成那件事，我想除了学习，前端应该是我坚持最久的事情。 其实最初接触前端的原因，是因为我觉得它简单，并且前景好，作为一名在计算机专业中的稀有物种，我觉得我必须找到一个适合女生的工作，听到很多师兄师姐，以及网上的评论，说前端比较适合女生，于是乎，就这么开始了，然而越接触，越发现前端其实是巨坑，要学的东西多且杂,而且经常变化，但是我想着我现在才大二，只要我坚持下去，总会是好的。 大一下的时候萌生了弄一个个人博客的想法，想想不错，在博客上面分享自己的想法和记录平时的技术文章和感悟也是相当不错的。暑假一直在查，上网百度，但始终没有方向，因为看不懂，幸运的是，这个学期加了一个新社团，我们的主席，一个超级厉害的人物，给了我们很多干货 ，我觉得能学到的东西非常多，也特别庆幸自己能进到这个社团。然后就在主席的干货中，看到了hexo，发现原来建博客并不是一件难事，尽管如此，我还是捣腾了很多天，当然很大部分原因是因为，我老是没坚持超过2个小时，就去看电视或者玩手机，惭愧啊。 好了，我的博客生活已经开始了，我的博客，还很丑，期待自己后期的完善~~","comments":true,"categories":[],"tags":[{"name":"感想","slug":"感想","permalink":"https://simmon12.github.io/tags/感想/"}]},{"title":"Hello World","date":"2017-02-05T16:28:27.886Z","path":"2017/02/06/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","comments":true,"categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://simmon12.github.io/tags/Hexo/"}]}]