[{"title":"MVVM框架","date":"2017-10-21T03:50:53.000Z","path":"2017/10/21/MVVM框架/","text":"MVVM框架笔记 MVVM的英文全称为：Model-View-ViewModel 核心为：数据模型的数据双向绑定 主要包括一下三个部分 ViewModel作为观察者的角色： 当Model层数据发生变化，ViewModel能观察到数据发生的变化，然后通知对于的视图View作出变化 当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据Model作变动 通过上述两种方式，实现 数据的双向绑定 MVVM框架的优点 针对有复杂交互逻辑的前端应用，可以省去许多手动触发DOM操作 通过Ajax数据持久化，可以进行局部刷新 常见的MVVM框架有：Angular.js , react.js vue.js","comments":true,"categories":[],"tags":[]},{"title":"thought","date":"2017-09-23T04:56:00.000Z","path":"2017/09/23/thought/","text":"记大三上一个雨后的中午广州的天气和往常一般调皮，毫无征兆地下雨，毫无征兆地停雨。我已经在这个世界留下了20年的痕迹，想起自己身边的人，小学，初中，高中，我们曾经呆在同一间教室，曾经困扰于同一道解析几何题，然而步入大学之后，就好像到了一个分岔路口，每个人似乎都朝着自己的方向渐行渐远。","comments":true,"categories":[],"tags":[{"name":"感想","slug":"感想","permalink":"https://simmon12.github.io/tags/感想/"}]},{"title":"响应式设计(一)","date":"2017-09-07T15:33:34.000Z","path":"2017/09/07/响应式设计/","text":"响应式网站的概念 流动网格，弹性图片和媒介查询是响应式设计的三大技术成分，但是崭新的思路也是必不可少的。与其把同样的内容割裂成不同设备专属的体验，我们可以通过媒介查询，渐进增强式地将一个设计在不同的阅读环境中加以优化。这么说并不是要绝对否定在任何情况下使用针对特定设备的独立网站，比如当移动用户在你的网站上的商业目的相比固定电脑用户要单一得多的时候，为两种情况分别输送不同的内容可能是最好的方法。然而我们也不需要固守在那样的设计思路里。如今越来越需要我们的设计能够呈现在一系列多种多样的体验中。响应式设计为我们指出了一条未来的路，是我们终于可以依照万物生灭的规律来进行设计了。来自: Responsive Web Design作者：伊森·马考特（Ethan Marcotte）https://site.douban.com/186898/widget/notes/10926516/note/241877629/ 响应式网站的组成 flexible grid layout 弹性网格布局 flexible image 弹性图片 media queries 媒介查询 常用的简单的可缩放的布局方式1234567.container &#123; width: 100%;&#125;.content &#123; width: 90%; margin: 2px auto;&#125; 在设置内容width属性的时候，不要直接设定特定的像素大小，而是通过百分比的方式，这样，当页面进行缩放的时候，宽度不会死死的固定，样式更加整体化和灵活。 媒介查询在CSS2中12&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"site.css\" media=\"screen\"/&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"print.css\" media=\"print\"/&gt; 在CSS3中1234@media all and (min-width: 800px) and (orientation: landscape) &#123; ......&#125;// all 可以是各种媒体设备，也可以是screen等，当只是针对某种设备的时候，为了兼容老的浏览器，最好在媒体设备前加上only，当and后面的表达式为真的时候，括号里的样式才会显示出来 viewport 视口 width：视口宽度 device-width: 设备屏幕的宽度 在桌面浏览器的时候，视口指的是浏览器主窗口的区域。在手机浏览器中，会出现3个视口概念 布局视口: 默认大小是厂商的值，一般为960px 可视视口（缩放时，可视视口是会发生改变的，默认是手机屏幕的大小） 理想视口：理想视口是布局视口在一个设备上的最佳尺寸，理想视口下的页面便于浏览器浏览阅读，不需要进行缩放。实现理想视口：（在响应式网站中最起码要有以下的语句）1&lt;meta name=\"viewport\" content=\"width=device-width\"/&gt; 用户在手机上不用进行缩放，体验会非常好，有一些甚至会禁止缩放如百度1234&lt;meta name=\"viewport\" content=\"width=device-width,minimum-scale = 1.0, //最小的缩放比例 maximum-scale = 1.0, // 最大的缩放比例user-scalable = no\"/&gt; // 禁用了用户缩放 em, rem, px一. px二. em 一种相对的长度单位，更加适合响应式设计 em相对的参照物为父元素的font-size 当一直向上找到html都没有设置font-size的时候，浏览器会有一个默认的em设置： 1em = 16px三. rem的相对参照物为根元素html，相于参照固定不变，所以好算，同样当没有设置font-size时，浏览器会有一个默认的rem设置：1rem = 16px一些单位的转换 font-size: 62.5% 1rem = 10px (10/16*100%) font-size: 100% 1rem = 16px 响应式图片一. 滚动式组件推荐（OwlCarousel2）二. 挑选第三方组件的标准 使用人数 是否开源 文档是否齐全 活跃性 小巧够用的组件（轻量级）三. 实现响应式图片的方式 js或服务端1234567891011121314$(document).ready(function() &#123; function makeImageResponsive() &#123; var width = $(window).width(); var img = $('.content img'); if (width &lt;= 480) &#123; img.attr('src', 'img/480.png'); &#125; else if (width &lt;= 800) &#123; img.attr('src': 'img/800.png'); &#125; else &#123; img.attr('src': 'img/1600.png'); &#125; &#125; $(window).on('resize load': makeImageResponsive);&#125;) 属于命令性的实现 srcset配合sizes 123&lt;img class=\"image\" src=\"img/480.png\" srcset = \"img/480.png 480w, img/800.png 800w, img/1600.png 1600w\" sizes=\"x\"&gt; x的值是包含这张图片的div的大小(50% 50vw, 50px 50px) picture（使用picturefill.min.js填补一些浏览器不支持picture标签的坑） 12345&lt;picture&gt; &lt;source srcset=\"img/ad001-l.png\" media=\"(min-width: 50em)\"&gt; &lt;source srcset=\"img/ad001-m.png\" media=\"(min-width: 30em)\"&gt; &lt;img src=\"img/ad001.png\" alt=\"2015年度报告\"&gt;&lt;/picture&gt; svg 压缩图片的网站地址https://tinyping.com做网站时，尤其是从设计师哪来的图片，通过压缩，可以提升页面载入速度，有时候可能会比优化代码时提升的速度还要快。","comments":true,"categories":[],"tags":[{"name":"响应式","slug":"响应式","permalink":"https://simmon12.github.io/tags/响应式/"}]},{"title":"随笔","date":"2017-04-17T02:08:39.000Z","path":"2017/04/17/随笔/","text":"忙碌的大二，迷茫的内心 忙里偷闲的一次博客，其实我是没有时间来写这篇博客的，我觉得写完这篇博客，也许就到了吃饭时间，这样本可以用来做OS实验的时间就没了，但是我还是选择了写博客，不为别的，只为写写自己所想所思的，清明的时候没有回家，呆在学校呆了3天，每天学学习，看看剧，偶尔睡睡午觉，偷偷懒，这种生活很惬意。去外面剪了个头发，与之前不同的是剪了个刘海，想说换换心情，换换形象。但是好像中分已经稳固地不能撼动了，刘海老是中分，导致出现此刻用笔盖夹刘海的我，可能之前有刘海的时光再也回不去了，就好像小时候那种学校出游前一晚那种激动兴奋的心情再也体会不到一样，有时候想想真的很难过。我的大二异常地忙碌，每天不是在做实验，就是在写报告的路上，我好像收获了很多，又好像并没有得到些什么，自己想学的东西，没学，看到别人的努力和认真，自己很羡慕很嫉妒，然而自己却没作出半点尝试，身边的人很优秀，自己很渣，但是换另外一个角度想想，我在一些人的眼里是不是或许也是优秀的人。但是我换不了角度，很多人说，要自信，要乐观，不要老是在意别人的目光，不要老是看别人，但是这些都只是说，谁能做到，说的好听，做的难。所以我有时候不懂得怎么去安慰别人，我连自己都安慰不了，怎么安慰别人，我说不出那些大道理，因为我做不到。这个星期又有一大堆实验，各种ddl又来了，又是各种熬夜，上星期天气冷，下了个水，就发烧了，感觉自己弱爆了。果然熬夜不行啊！！！我不想每次都找借口，前端还有一大堆的东西没学呢！！！","comments":true,"categories":[],"tags":[{"name":"感想","slug":"感想","permalink":"https://simmon12.github.io/tags/感想/"}]},{"title":"Git","date":"2017-04-06T16:59:13.000Z","path":"2017/04/07/Git/","text":"Windows下Git的安装和使用详细教程： http://blog.jobbole.com/78960/ Linux下Git的安装和使用详细教程: http://www.cnblogs.com/20145335hh/p/5954564.html","comments":true,"categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://simmon12.github.io/tags/Git/"}]},{"title":"javascript 练习分析(四)","date":"2017-04-02T11:04:10.000Z","path":"2017/04/02/原型/","text":"对原型练习的理解12345function Ninja() &#123;&#125;var ninja = new Ninja();assert(typeof ninja == \"object\", \"However the type of the instance is still an object\");assert(ninja instanceof Ninja, \"The object was instantiated properly.\");assert(ninja.constructor == Ninja, \"The ninja object was created by the Ninja function\"); 知识点分析 1.创建对象之构造函数模式 123456789function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; alert(this.name); &#125;;&#125;var person1 = new Person(\"ss\", 20, \"software Engineer\"); 注意: 函数名Person使用的是大写字母P，按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头，并且构造函数本身也是函数，只不过用于创建对象而已。 创建Person的新实例，必须使用new操作符，若var person1 = Person(), 则person1是undefined。person1对象有一个constructor(构造函数)属性，该属性指向Person。准确来说constructor属性关联的就是当初创建这个对象实例的构造函数。 所以在开篇代码中ninja.constructor == Ninja。 typeof ninja == “object” 其中 typeof是一个操作符，用来测定给定变量的数据类型。 “undefined” — 如果这个值未定义 “boolen” ——–如果这个值是布尔值 “string”———-如果这个值是字符串 “number”——–如果这个值是数字 “object”———-如果这个值是对象或null ”function“——-如果这个值是函数 ninja instanceof Ninja ,其中instanceof运算符用来测试一个对象在其原型链中是否存在一个构造函数的prototype属性. 语法: object instanceof constructor object : 要检测的对象 constructor: 某个构造函数","comments":true,"categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://simmon12.github.io/tags/javascript/"}]},{"title":"javascript练习分析-三","date":"2017-03-21T02:59:20.000Z","path":"2017/03/21/javascript练习分析-三/","text":"Closures(闭包)123456789101112function f1() &#123; var n = 999; nAdd = function() &#123;n+=1&#125; function f2() &#123; alert(n)&#125;; return f2;&#125;var result = f1();result(); // 999;nAdd();result(); //1000;nAdd();result(); //1001; 读书笔记一.闭包是指有权访问另一个函数作用域中的变量的函数，闭包最大的两个用处是：a.可以读取函数内部的变量 b. 让这些变量的值始终保持在内存中.在上面的代码中，result实际上就是闭包函数f2,它一共运行了3次，第一次为999，第二次，第三次一次为1000，1001，这说明了函数f1的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。因为f1是f2的父函数，而f2被赋值给一个全局变量reslut，这导致f2始终在内存中，而f2依赖f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制回收。在第一点的解释中设计到一些知识点，需要了解这些知识点才能更好地了解闭包1.作用域链当代码在一个环境中执行时，会创建变量对象的一个作用域链，其用途是保证对执行环境有权访问的所有变量和函数的有序访问。 作用域的前端，始终都是当前执行的代码所在环境的变量对象，若这个环境是函数，则将其活动对象作为变量对象。作用域链中的下一个变量对象来自包含环境，而再下一个变量对象则来自下一个包含环境，这样一直延续到全局执行环境。标识符解析是沿着作用域链一级一级地搜索标识符地过程，都是从作用域链的前端开始，然后逐级往后，直到找到标识符。注意的是：如果在逐级往后搜索的过程中找到标识符，则马上停止搜索，即如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符。2.变量的作用域(全局变量和局部变量)与C++等语言的重要区别之一是，javascript是没有块级作用域的，即并不是以花括号{}封闭的来拥有自己的作用域，而是以函数function为分界。区分全局变量和局部变量，只需理解这一点: 使用var声明的变量自动被添加到最接近的环境中，而如果初始变量时没有使用var声明，该变量会自动被添加到全局变量 3.垃圾收集机制(后续补充)闭包与变量闭包只能取得包含函数(即外部函数)中任何变量的最后一个值，闭包所保存的是整个变量对象，而不是某个特殊的变量12345678910111213141516171819202122function creatFunction() &#123; var result = new Array(); for (var i = 0; i &lt; 10; i++) &#123; result[i] = function () &#123; return i; &#125;; &#125; return result; //result=[10,10,10,...,10]返回一个都是10的数组，因为每个函数的作用域链中都&#125; //保存着crcreatFunction()函数的活动对象，所以他们引用的都是同一个变量i，crcreatFunction函数返回后，i的值是10； //创建另一个匿名函数强制让闭包的行为符合预期function creatFunction() &#123; var result = new Array(); for(var i = 0; i &lt; 10; i++) &#123; result[i] = function(num) &#123; return function() &#123; return num; &#125; &#125;(i); &#125; return result; //result = [0,1,2,3,4,...9]&#125;","comments":true,"categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://simmon12.github.io/tags/javascript/"}]},{"title":"常见函数模板总结","date":"2017-03-18T03:08:55.000Z","path":"2017/03/18/常见函数模板总结/","text":"判断是否为素数12345678910function isPrime( num ) &#123; var prime = num != 1; //Everything but 1 can be prime for(var i = 2; i &lt; num ; i++) &#123; if(num &amp; i == 0) &#123; prime = false; break; &#125; &#125; return prime;&#125;","comments":true,"categories":[],"tags":[{"name":"template","slug":"template","permalink":"https://simmon12.github.io/tags/template/"}]},{"title":"Javascript练习分析(二)","date":"2017-03-17T06:26:26.000Z","path":"2017/03/17/Javascript练习分析-二/","text":"Function 笔记12345678910111213var ninja = &#123; yell: function(n) &#123; return n &gt; 0 ? ninja.yell(n-1) + \"a\" : \"hiy\"; &#125;&#125;;console.log(ninja.yell(4)) // hiyaaaavar samurai = &#123; yell: ninja.yell &#125;;var ninja = null;try &#123; samurai.yell(4);&#125; catch(e) &#123; console.log(\"mistake\") &#125; //mistake 知识点梳理 一.函数是对象，函数名是指针(是指向函数对象的指针,不会与某个函数绑定)。 换句话说一个函数可能有多个名字。函数的名字仅仅只是一个包含指针的变量而已，因此，计时在不同的环境下执行，全局的某()函数和o.某()函数指向的仍然是同一个函数。二.函数声明提升(function declaration hoisting) 函数声明和函数表达式是存在区别的。解析器会率先读取函数声明，并使其在执行任何代码前可以访问；而函数表达式则必须等到解析器执行到它所在的代码行，才会真正被解释执行 12345678alert(sum1(10,10)); //20function sum1(n1, n2) &#123; return n1 + n2;&#125;alert(sum2(10,10)); // sum2 is not a function 运行错误var sum2 = function(n1, n2) &#123; return n1 + n2;&#125; 三.函数内部有两个特殊的对象，arguments和this。 arguments是一个类数组对象，包含着传入函数中的所有参数。arguments对象有一个叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。在最开始的递归调用代码中，sumurai.yell(4)会调用ninja()函数，但是ninja函数已经变为null，此时调用自然会发生错误。为了消除这种函数名与函数的执行耦合在一起的现象，可以使用arguments.callee。将代码改成如下所示，即可： 12345var ninja = &#123; yell: function(n) &#123; return n &gt; 0 ? arguments.callee(n-1) + 'a' : 'hiy'; //arguments.callee is the function itself. &#125;&#125;; caller这个属性中保存着调用当前函数的函数的引用，即与callee一样也是一个指针，不过caller指向的是调用当前函数的函数。 解决上面问题的第二种方法是给匿名函数命名 12345var ninja = &#123; yell: function yell(n) &#123; return n &gt; 0 ? yell(n-1) + \"a\" : \"hiy\"; &#125;&#125;; 四.重排序方法–reverse()和sort()默认情况下，sort()方法按升序排列数组项(从小到大),为了实现排序，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序，即使数组中的每一项都是数值，sort()方法比较的也是字符串。123var values = [0, 1, 5, 10, 15];values.sort();alert(values); // 0,1,10,15 出现10在5的前面的原因是：虽然数值5小于10，但是在进行字符串比较的时候，”10”位于”5”的前面。可见这种排序方式在很多情况下都不是最佳方案，所以sort()方法可以接收一个比较函数作为参数，以便指定哪个值位于哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则放回0，如果第一个参数应该位于第二个参数之后则返回一个正数。12345678function compare(value1, value2) &#123; if(value1 &lt; value2) return -1; else if(value1 == value2) return 0; else return 1;&#125;var values = [0,1,5,10,15];values.sort(compare);alert(values); //0,1,5,19,15 作为值的函数,函数名本身就是变量，因此可以从一个函数返回另外一个函数123456789101112131415// 可以根据某个对象属性对数组进行排序function createComparsionFunction(propertyName) &#123; return function(object1, object2) &#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; if(value1 &lt; value2) return -1; else if( value1 &gt; value2) return 1; else return 0; &#125;&#125;var data = [&#123;name: \"Zhang\", age: 28&#125;, &#123;name: \"feng\", age: 23&#125;];data.sort(createComparsionFunction(\"name\"));alert(data[0].name); //Zhangdata.sort(createComparsionFunction(\"age\"));alert(data[0].age); //23","comments":true,"categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://simmon12.github.io/tags/javascript/"}]},{"title":"javascript练习分析(一)","date":"2017-03-16T15:42:07.000Z","path":"2017/03/16/javascript练习分析/","text":"理解 Prototype.js的bind()函数fun.bind(this,arg1,arg2)bind()方法会创建一个新的函数，称为绑定函数，fun方法在this环境下调用(这里的this可以绑定到任意对象),该方法可传入连个参数，第一个参数作为this，第二个及以后的参数则作为函数的参数调用123456789// The .bind method from Prototype.jsFunction.prototype.bind = function() &#123; var fn = this, args = Array.prototype.slice.call(arguments), object = args.shift(); return function() &#123; return fn.apply(object, args.concat(Array.prototype.slice.call(arguments)); ) &#125;&#125; 一.Array.slice()和shift()和concat()slice()有两种，一种是string.slice()，另外一种是Array.slice().在数组Array中，slice()能够基于当前数组中的一或多个项创建一个新数组。它可以接受一个或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项，但不包括结束位置的项，注意，slice()方法不会影响原始数组shift()指删除一个数组最前面的值，并且放回删除值.concat()可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前一个数组的副本，然后接收到的参数添加到这个副本的末尾，最后返回新构建的数组。 var colors = [\"red\", \"green\", \"blue\", \"yellow\", \"purple\"]; var color1 = colors.concat(\"yellow\",[\"black\",\"brown\"]); var colors2 = colors.slice(1); var colors3 = colors.slice(1,4); alert(color1); //red,green,blue,yellow,purple,yellow,black,brown alert(colors2); //green,blue,yellow,purple alert(colors3); //green,blue,yellow alert(colors); //red,green,blue,yellow,purple 二.call()和apply()call()和apply()方法主要是用来扩充函数的作用域(把第一个参数作为自己的this)call()和apply()方法接收两个参数:apply():第一个参数是作用域，第二个是参数数组，其中第二个参数可以是数组实例，也可以是arguments对象。call():参数方式与apply一致，区别在于:传参的方式不同，其参数必须逐个写入 三.Array.prototype.slice.call(arguments)arguments是一个关键字，代表当前参数，在Javascript中虽然arguments表面上以数组形式来表示，但实际上没有原生slice的功能，所以要使用call方法算是对arguments对象不完整数组功能的修正。Array.prototype.slice.call(arguments) === Array.prototype.slice.call(arguments,0)Array.prototype.slice调用的是Array的原型方法，对于真正的数组是有slice()方法，但是对于像arguments或者自己定义的一些类数组对象虽然存在length等若干属性，但是并没有slice()方法，所以对于这种类数组对象就得使用原型方法来使用slice()方法，即Array.prototype.slice.(如果在自定义中的类数组对象中自定义了slice()方法，就可以自然地直接调用了)。因此，Array.prototype.slice.call(arguments,0)可以理解为：对于arguments类数组，我们调用Array.prototype.slice原型方法，并用call()方法将作用域限定在arguments中，此时：Array.prototype === arguments, 用参数0位slice()方法中地第一个参数，即开始位置索引，_通过这种方法就将arguments类数组转换位了真数组。 var a = { length: 2, 0: 'first', 1: 'second' }; Array.prototype.slice.call(a); //[\"first\",\"second\"] var a = {length: 2}; Array.prototype.slice.call(a); //[\"undefined\",\"undefined\"]","comments":true,"categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://simmon12.github.io/tags/javascript/"}]},{"title":"图解HTTP","date":"2017-03-05T07:00:59.000Z","path":"2017/03/05/图解HTTP/","text":"《图解HTTP》 读书笔记之网络基础TCP/IP计算机与网络设备要相互通信，双方就必须基于相同的方法，这些方法需要同一种规则，这种规则即称为协议。 像这样把与互联网相关联的协议集合起来总称为TCP/IP。","comments":true,"categories":[],"tags":[{"name":"HTTP协议","slug":"HTTP协议","permalink":"https://simmon12.github.io/tags/HTTP协议/"}]},{"title":"我的第一篇博客","date":"2017-02-07T08:32:48.000Z","path":"2017/02/07/我的第一篇博客/","text":"首先我必须说一点，从小到大我都觉得我的语言组织能力很差，怎么说呢？通常情况下，我会把一件事情说的特别的冗长，后来我仔细地想了想，其实这并不能完全怪我，要怪就得怪那万恶的高考语文作文，说了那么久的废话，我来谈谈正话，其实也不能算是正话，这篇文章的主要目的其实就是随便谈谈而已。 我很开心，为什么呢？因为我终于拥有了一篇属于自己的博客啦，我从大一的时候就一直希望自 己能弄出一个个人网站，因为我想成为一名前端工程师，我想如果我能够熟悉一个网站建立的全过程，我应该就能完整地了解前端后端的全过程，但是我发现这个过程异常的艰辛，偏偏我又是那种很难集中注意力坚持做完一件事的人，我不知道我能不能算是一个有恒心，肯坚持的人，因为一方面我很难坚持完成一件事超过一个小时，另一方面我，我却能长时间地想要完成那件事，我想除了学习，前端应该是我坚持最久的事情。 其实最初接触前端的原因，是因为我觉得它简单，并且前景好，作为一名在计算机专业中的稀有物种，我觉得我必须找到一个适合女生的工作，听到很多师兄师姐，以及网上的评论，说前端比较适合女生，于是乎，就这么开始了，然而越接触，越发现前端其实是巨坑，要学的东西多且杂,而且经常变化，但是我想着我现在才大二，只要我坚持下去，总会是好的。 大一下的时候萌生了弄一个个人博客的想法，想想不错，在博客上面分享自己的想法和记录平时的技术文章和感悟也是相当不错的。暑假一直在查，上网百度，但始终没有方向，因为看不懂，幸运的是，这个学期加了一个新社团，我们的主席，一个超级厉害的人物，给了我们很多干货 ，我觉得能学到的东西非常多，也特别庆幸自己能进到这个社团。然后就在主席的干货中，看到了hexo，发现原来建博客并不是一件难事，尽管如此，我还是捣腾了很多天，当然很大部分原因是因为，我老是没坚持超过2个小时，就去看电视或者玩手机，惭愧啊。 好了，我的博客生活已经开始了，我的博客，还很丑，期待自己后期的完善~~","comments":true,"categories":[],"tags":[{"name":"感想","slug":"感想","permalink":"https://simmon12.github.io/tags/感想/"}]},{"title":"Hello World","date":"2017-02-05T16:28:27.886Z","path":"2017/02/06/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","comments":true,"categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://simmon12.github.io/tags/Hexo/"}]}]